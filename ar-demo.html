<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4DVV AR - Three.js WebXR</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow-x: hidden;
        }

        .header {
            padding: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 100;
        }

        .viewer-container {
            position: relative;
            height: 60vh;
            margin: 20px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        #canvas3d {
            width: 100%;
            height: 100%;
            display: block;
            background: #1a1a1a;
        }

        .ar-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            padding: 15px;
            display: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .ar-controls.active {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .timeline-ar {
            width: 300px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            position: relative;
            cursor: pointer;
        }

        .timeline-progress-ar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            border-radius: 20px;
            width: 0%;
            position: relative;
        }

        .timeline-thumb {
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .frame-counter {
            color: white;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .manipulation-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover, .control-btn.active {
            background: rgba(76, 175, 80, 0.5);
        }

        .main-controls {
            padding: 20px;
            text-align: center;
        }

        .ar-button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            transition: all 0.3s ease;
        }

        .ar-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .ar-button:disabled {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        .status-info {
            margin-top: 15px;
            font-size: 14px;
            opacity: 0.8;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-left: 3px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .surface-grid {
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        .surface-grid.visible {
            opacity: 0.8;
        }

        .error-message {
            color: #ff6b6b;
            padding: 10px;
            text-align: center;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 10px;
            margin: 10px 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé≠ 4DVV AR Player - Three.js</h1>
        <p>Advanced Gaussian Splatting with Full AR Controls</p>
    </div>

    <div class="viewer-container">
        <canvas id="canvas3d"></canvas>
        
        <div class="loading-overlay" id="loadingOverlay">
            <div class="spinner"></div>
            <div id="loadingText">Initializing AR system...</div>
        </div>
    </div>

    <div class="main-controls">
        <button class="control-btn" onclick="testFirstFrame()" style="margin-bottom: 10px;">
            üß™ Test Load Frame 1
        </button>
        <br>
        <button class="ar-button" id="arButton" onclick="startAR()" disabled>
            üöÄ Launch AR Experience
        </button>">
            üöÄ Launch AR Experience
        </button>
        <div class="status-info">
            <div id="statusText">üß™ Test frame loading first ‚Ä¢ Then AR will be enabled</div>
            <div style="margin-top: 5px; font-size: 12px;">
                Features: Surface Detection ‚Ä¢ Object Manipulation ‚Ä¢ 25fps Animation
            </div>
        </div>
    </div>

    <!-- AR Controls (shown during AR session) -->
    <div class="ar-controls" id="arControls">
        <div class="frame-counter" id="frameCounter">Frame 1 / 400</div>
        
        <div class="timeline-ar" id="timelineAR" onclick="seekFrame(event)">
            <div class="timeline-progress-ar" id="timelineProgressAR">
                <div class="timeline-thumb"></div>
            </div>
        </div>
        
        <div class="manipulation-controls">
            <button class="control-btn" id="playBtn" onclick="togglePlayback()">‚ñ∂Ô∏è Play</button>
            <button class="control-btn" onclick="toggleGrid()">üìê Grid</button>
            <button class="control-btn" onclick="resetObject()">üîÑ Reset</button>
            <button class="control-btn" onclick="exitAR()">‚ùå Exit</button>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>
    <script src="https://unpkg.com/three@0.158.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // Global variables
        let scene, camera, renderer, arSession;
        let currentModel = null;
        let currentFrame = 1;
        let totalFrames = 400;
        let isPlaying = false;
        let animationId = null;
        let frameLoader = new Map(); // Cache for GLB frames
        let surfaceGrid = null;
        let manipulationMode = 'none'; // 'move', 'scale', 'rotate'
        let hitTestSource = null;
        let lastHitResult = null;
        let objectPlaced = false;

        // Frame management
        const PRELOAD_BUFFER = 3; // Preload 3 frames ahead/behind
        const TARGET_FPS = 25;
        const FRAME_DURATION = 1000 / TARGET_FPS; // 40ms per frame

        // DOM elements
        const canvas = document.getElementById('canvas3d');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const arButton = document.getElementById('arButton');
        const arControls = document.getElementById('arControls');
        const frameCounter = document.getElementById('frameCounter');
        const timelineProgressAR = document.getElementById('timelineProgressAR');
        const playBtn = document.getElementById('playBtn');
        const statusText = document.getElementById('statusText');

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true, 
                alpha: true 
            });
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Basic lighting for non-AR mode
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Create surface detection grid
            createSurfaceGrid();

            updateStatus('Scene initialized');
        }

        // Create surface detection grid
        function createSurfaceGrid() {
            const gridGeometry = new THREE.PlaneGeometry(2, 2, 20, 20);
            const gridMaterial = new THREE.MeshBasicMaterial({
                color: 0x4CAF50,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            
            surfaceGrid = new THREE.Mesh(gridGeometry, gridMaterial);
            surfaceGrid.rotateX(-Math.PI / 2); // Lay flat
            surfaceGrid.visible = false;
            scene.add(surfaceGrid);
        }

        // Load GLB frame
        async function loadFrame(frameNumber) {
            return new Promise((resolve, reject) => {
                // Check cache first
                if (frameLoader.has(frameNumber)) {
                    resolve(frameLoader.get(frameNumber));
                    return;
                }

                const loader = new THREE.GLTFLoader();
                const frameFile = `data/frame-${String(frameNumber).padStart(6, '0')}.glb`;
                
                console.log(`Loading frame ${frameNumber} from: ${frameFile}`);
                
                loader.load(
                    frameFile,
                    (gltf) => {
                        const model = gltf.scene.clone();
                        frameLoader.set(frameNumber, model);
                        
                        // Limit cache size (keep only recent frames)
                        if (frameLoader.size > PRELOAD_BUFFER * 6) {
                            const oldestFrame = Math.max(1, frameNumber - PRELOAD_BUFFER * 3);
                            frameLoader.delete(oldestFrame);
                        }
                        
                        resolve(model);
                    },
                    (progress) => {
                        const percent = (progress.loaded / progress.total * 100).toFixed(0);
                        updateLoadingText(`Loading frame ${frameNumber}: ${percent}%`);
                    },
                    (error) => {
                        console.error(`Failed to load frame ${frameNumber} from ${frameFile}:`, error);
                        showError(`Frame ${frameNumber} not found. Check if data/frame-${String(frameNumber).padStart(6, '0')}.glb exists`);
                        reject(error);
                    }
                );
            });
        }

        // Preload frames around current frame
        async function preloadFrames(centerFrame) {
            const promises = [];
            
            for (let i = -PRELOAD_BUFFER; i <= PRELOAD_BUFFER; i++) {
                const frameNum = centerFrame + i;
                if (frameNum >= 1 && frameNum <= totalFrames && !frameLoader.has(frameNum)) {
                    promises.push(loadFrame(frameNum).catch(() => {})); // Ignore errors
                }
            }
            
            await Promise.allSettled(promises);
        }

        // Set current frame
        async function setFrame(frameNumber) {
            if (frameNumber < 1 || frameNumber > totalFrames) return;
            
            try {
                const newModel = await loadFrame(frameNumber);
                
                // Remove current model
                if (currentModel) {
                    scene.remove(currentModel);
                }
                
                // Add new model
                currentModel = newModel.clone();
                
                // Apply current position/scale/rotation if object was placed
                if (objectPlaced && lastHitResult) {
                    currentModel.position.copy(lastHitResult.position);
                    currentModel.scale.setScalar(0.1); // Start small for mobile
                }
                
                scene.add(currentModel);
                currentFrame = frameNumber;
                
                updateFrameDisplay();
                preloadFrames(frameNumber); // Preload nearby frames
                
            } catch (error) {
                console.error('Error setting frame:', error);
                showError(`Failed to load frame ${frameNumber}`);
            }
        }

        // Animation playback
        let lastFrameTime = 0;
        function playAnimation() {
            if (!isPlaying) return;
            
            const currentTime = Date.now();
            if (currentTime - lastFrameTime >= FRAME_DURATION) {
                const nextFrame = currentFrame >= totalFrames ? 1 : currentFrame + 1;
                setFrame(nextFrame);
                lastFrameTime = currentTime;
            }
            
            animationId = requestAnimationFrame(playAnimation);
        }

        function togglePlayback() {
            isPlaying = !isPlaying;
            playBtn.textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
            
            if (isPlaying) {
                lastFrameTime = Date.now();
                playAnimation();
            } else if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        // Timeline interaction
        function seekFrame(event) {
            const rect = event.currentTarget.getBoundingClientRect();
            const position = (event.clientX - rect.left) / rect.width;
            const targetFrame = Math.max(1, Math.round(position * totalFrames));
            setFrame(targetFrame);
        }

        function updateFrameDisplay() {
            frameCounter.textContent = `Frame ${currentFrame} / ${totalFrames}`;
            const progress = ((currentFrame - 1) / (totalFrames - 1)) * 100;
            timelineProgressAR.style.width = `${Math.max(0, progress)}%`;
        }

        // Surface grid toggle
        function toggleGrid() {
            if (surfaceGrid) {
                surfaceGrid.visible = !surfaceGrid.visible;
                updateStatus(surfaceGrid.visible ? 'Surface grid enabled' : 'Surface grid disabled');
            }
        }

        // Object manipulation
        function resetObject() {
            if (currentModel && lastHitResult) {
                currentModel.position.copy(lastHitResult.position);
                currentModel.scale.setScalar(0.1);
                currentModel.rotation.set(0, 0, 0);
                updateStatus('Object reset to original position');
            }
        }

        // WebXR AR Session
        async function startAR() {
            if (!navigator.xr) {
                showError('WebXR not supported on this device');
                return;
            }

            try {
                updateLoadingText('Requesting AR session...');
                loadingOverlay.classList.remove('hidden');

                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    throw new Error('AR not supported');
                }

                arSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['local', 'hit-test']
                });

                await renderer.xr.setSession(arSession);
                
                // Initialize hit testing
                const referenceSpace = await arSession.requestReferenceSpace('viewer');
                hitTestSource = await arSession.requestHitTestSource({ space: referenceSpace });

                // Set up AR session event listeners
                arSession.addEventListener('end', onARSessionEnd);

                // Show AR controls
                arControls.classList.add('active');
                loadingOverlay.classList.add('hidden');
                
                // Load first frame
                await setFrame(1);
                
                updateStatus('AR session active - Tap to place object');
                renderer.setAnimationLoop(renderAR);

            } catch (error) {
                console.error('AR initialization failed:', error);
                showError(`AR failed: ${error.message}`);
                loadingOverlay.classList.add('hidden');
            }
        }

        // AR render loop
        function renderAR(timestamp, frame) {
            if (!frame) return;

            // Hit testing for surface detection
            if (hitTestSource && !objectPlaced) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const referenceSpace = renderer.xr.getReferenceSpace();
                    const hitPose = hit.getPose(referenceSpace);
                    
                    if (hitPose) {
                        // Update surface grid position
                        if (surfaceGrid) {
                            surfaceGrid.position.setFromMatrixPosition(hitPose.transform.matrix);
                            surfaceGrid.visible = true;
                        }
                        
                        lastHitResult = {
                            position: new THREE.Vector3().setFromMatrixPosition(hitPose.transform.matrix),
                            quaternion: new THREE.Quaternion().setFromRotationMatrix(hitPose.transform.matrix)
                        };
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // Touch interaction for AR
        canvas.addEventListener('touchstart', onARTouch);

        function onARTouch(event) {
            if (!arSession || !lastHitResult) return;
            
            event.preventDefault();
            
            if (!objectPlaced && currentModel) {
                // Place object at hit location
                currentModel.position.copy(lastHitResult.position);
                currentModel.scale.setScalar(0.1);
                objectPlaced = true;
                
                if (surfaceGrid) {
                    surfaceGrid.visible = false;
                }
                
                updateStatus('Object placed - Use controls to manipulate');
            }
        }

        // Exit AR
        function exitAR() {
            if (arSession) {
                arSession.end();
            }
        }

        function onARSessionEnd() {
            arControls.classList.remove('active');
            renderer.setAnimationLoop(null);
            objectPlaced = false;
            
            if (surfaceGrid) {
                surfaceGrid.visible = false;
            }
            
            updateStatus('AR session ended');
        }

        // Utility functions
        function updateLoadingText(text) {
            loadingText.textContent = text;
        }

        function updateStatus(text) {
            statusText.textContent = text;
        }

        function showError(message) {
            const existingError = document.querySelector('.error-message');
            if (existingError) existingError.remove();
            
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            document.body.insertBefore(errorDiv, document.querySelector('.viewer-container'));
            
            setTimeout(() => errorDiv.remove(), 5000);
        }

        // Test function to verify frame loading
        async function testFirstFrame() {
            try {
                updateLoadingText('Testing frame 1 loading...');
                loadingOverlay.classList.remove('hidden');
                
                console.log('Attempting to load: data/frame-000001.glb');
                await setFrame(1);
                
                updateStatus('‚úÖ Frame 1 loaded successfully!');
                loadingOverlay.classList.add('hidden');
                
                // Enable AR button if test passes
                arButton.disabled = false;
                
            } catch (error) {
                console.error('Frame loading test failed:', error);
                showError(`Frame loading failed: ${error.message}`);
                loadingOverlay.classList.add('hidden');
            }
        }

        // Device detection and compatibility
        function checkCompatibility() {
            if (!navigator.xr) {
                updateStatus('WebXR not supported');
                arButton.disabled = true;
                return;
            }

            navigator.xr.isSessionSupported('immersive-ar').then(supported => {
                if (supported) {
                    updateStatus('AR supported ‚Ä¢ Test frame loading first');
                    // Don't enable AR button yet - require frame test first
                } else {
                    updateStatus('AR not supported on this device');
                    arButton.disabled = true;
                }
            });
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
        });

        // Initialize
        window.addEventListener('load', () => {
            initScene();
            checkCompatibility();
            loadingOverlay.classList.add('hidden');
        });
    </script>
</body>
</html>