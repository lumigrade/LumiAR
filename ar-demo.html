<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üé≠ 4DVV .splatv AR - 4D Gaussian Splatting</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #controls { position: absolute; top: 10px; left: 10px; z-index: 10; }
        button { margin: 5px; padding: 8px 12px; }
        #info { position: absolute; bottom: 10px; left: 10px; z-index: 10; color: white; background: rgba(0,0,0,0.5); padding: 10px; }
        #spinner { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #enter { display: none; }
    </style>
</head>
<body>
    <div id="spinner">Loading gsplat.js VideoRenderProgram...</div>
    <button id="enter">Enter AR</button>

    <div id="controls">
        <div>
            <button>üìÅ Load</button>
            <button>üß™ Original</button>
            <button>üîß Fixed</button>
            <button>‚úÖ Example</button>
            <button>‚¨áÔ∏è Download</button>
        </div>
        <div>
            <button>‚ñ∂Ô∏è Play</button>
            <button>üöÄ AR</button>
        </div>
    </div>

    <div id="info">
        <p>Time: 0.00s / 16.00s</p>
        <p>Gaussians: 0</p>
    </div>

    <script>
        let refSpace;
        let gl;

        let worldTransform = [0.99, -0.05, 0.16, 0, -0.05, -1, -0.05, 0, 0.16, 0.04, -0.99, 0, -0.08, 1.63, -0.1, 1];

        const params = new URLSearchParams(location.search);
        try {
          worldTransform = JSON.parse(decodeURIComponent(location.hash.slice(1)));
        } catch (err) {}

        const vertexShaderSource = `
          #version 300 es
          precision highp float;
          precision highp int;
          
          uniform highp usampler2D u_texture;
          uniform mat4 projection, view;
          uniform vec2 focal;
          uniform vec2 viewport;
          uniform float time;
          
          in vec2 position;
          in int index;
          
          out vec4 vColor;
          out vec2 vPosition;
          
          void main () {
              gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

              uvec4 motion1 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2) | 3u, uint(index) >> 10), 0);
              vec2 trbf = unpackHalf2x16(motion1.w);
              float dt = time - trbf.x;

              float topacity = exp(-1.0 * pow(dt / trbf.y, 2.0));
              if(topacity < 0.02) return;

              uvec4 motion0 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2) | 2u, uint(index) >> 10), 0);
              uvec4 static0 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2), uint(index) >> 10), 0);

              vec2 m0 = unpackHalf2x16(motion0.x), m1 = unpackHalf2x16(motion0.y), m2 = unpackHalf2x16(motion0.z), 
                   m3 = unpackHalf2x16(motion0.w), m4 = unpackHalf2x16(motion1.x); 
              
              vec4 trot = vec4(unpackHalf2x16(motion1.y).xy, unpackHalf2x16(motion1.z).xy) * dt;
              vec3 tpos = (vec3(m0.xy, m1.x) * dt + vec3(m1.y, m2.xy) * dt*dt + vec3(m3.xy, m4.x) * dt*dt*dt);
              
              vec4 cam = view * vec4(uintBitsToFloat(static0.xyz) + tpos, 1);
              vec4 pos = projection * cam;
          
              float clip = 1.2 * pos.w;
              if (pos.z < -clip || pos.x < -clip || pos.x > clip || pos.y < -clip || pos.y > clip) return;
              uvec4 static1 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2) | 1u, uint(index) >> 10), 0);

              vec4 rot = vec4(unpackHalf2x16(static0.w).xy, unpackHalf2x16(static1.x).xy) + trot;
              vec3 scale = vec3(unpackHalf2x16(static1.y).xy, unpackHalf2x16(static1.z).x);
              rot /= sqrt(dot(rot, rot));
          
              mat3 S = mat3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);
              mat3 R = mat3(
                1.0 - 2.0 * (rot.z * rot.z + rot.w * rot.w), 2.0 * (rot.y * rot.z - rot.x * rot.w), 2.0 * (rot.y * rot.w + rot.x * rot.z),
                2.0 * (rot.y * rot.z + rot.x * rot.w), 1.0 - 2.0 * (rot.y * rot.y + rot.w * rot.w), 2.0 * (rot.z * rot.w - rot.x * rot.y),
                2.0 * (rot.y * rot.w - rot.x * rot.z), 2.0 * (rot.z * rot.w + rot.x * rot.y), 1.0 - 2.0 * (rot.y * rot.y + rot.z * rot.z));
              mat3 M = S * R;
              mat3 Vrk = 4.0 * transpose(M) * M;
              mat3 J = mat3(
                focal.x / cam.z, 0., -(focal.x * cam.x) / (cam.z * cam.z), 
                0., -focal.y / cam.z, (focal.y * cam.y) / (cam.z * cam.z), 
                0., 0., 0.
            );
          
              mat3 T = transpose(mat3(view)) * J;
              mat3 cov2d = transpose(T) * Vrk * T;
          
              float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;
              float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));
              float lambda1 = mid + radius, lambda2 = mid - radius;
          
              if(lambda2 < 0.0) return;
              vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));
              vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
              vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);
              
              uint rgba = static1.w;
              vColor = 
                clamp(pos.z/pos.w+1.0, 0.0, 1.0) * 
                vec4(1.0, 1.0, 1.0, topacity) *
                vec4(
                  (rgba) & 0xffu, 
                  (rgba >> 8) & 0xffu, 
                  (rgba >> 16) & 0xffu, 
                  (rgba >> 24) & 0xffu) / 255.0;

              vec2 vCenter = vec2(pos) / pos.w;
              gl_Position = vec4(
                  vCenter 
                  + position.x * majorAxis / viewport 
                  + position.y * minorAxis / viewport, 0.0, 1.0);

              vPosition = position;
          }
          `.trim();

        const fragmentShaderSource = `
          #version 300 es
          precision highp float;
          
          in vec4 vColor;
          in vec2 vPosition;
          
          out vec4 fragColor;
          
          void main () {
              float A = -dot(vPosition, vPosition);
              if (A < -4.0) discard;
              float B = exp(A) * vColor.a;
              fragColor = vec4(B * vColor.rgb, B);
          }
          
          `.trim();

        const vertices = [
          -2.0, -2.0,
          2.0, -2.0,
          0.0,  2.0
        ];

        function createWorker(self) {
  let lastProj;
  let positions;
  let viewProj;
  let vertexCount;
  let lastVertexCount;
  let sortRunning = false;
  var _floatView = new Float32Array(1);
  var _int32View = new Int32Array(_floatView.buffer);

  function floatToHalf(float) {
    _floatView[0] = float;
    var f = _int32View[0];
    var sign = (f >> 31) & 0x0001;
    var exp = (f >> 23) & 0x00ff;
    var frac = f & 0x007fffff;
    var newExp;
    if (exp == 0) {
      newExp = 0;
    } else if (exp < 113) {
      newExp = 0;
      frac |= 0x00800000;
      frac = frac >> (113 - exp);
      if (frac & 0x01000000) {
        newExp = 1;
        frac = 0;
      }
    } else if (exp < 142) {
      newExp = exp - 112;
    } else {
      newExp = 31;
      frac = 0;
    }
    return (sign << 15) | (newExp << 10) | (frac >> 13);
  }

  function packHalf2x16(x, y) {
    return (floatToHalf(x) | (floatToHalf(y) << 16)) >>> 0;
  }

  function runSort(viewProj) {
    if (!positions) return;
    if (lastVertexCount == vertexCount) {
      let dist = Math.hypot(...[2, 6, 10].map((k) => lastProj[k] - viewProj[k]));
      if (dist < 0.01) return;
    } else {
      lastVertexCount = vertexCount;
    }

    console.time("sort");
    let maxDepth = -Infinity;
    let minDepth = Infinity;
    let sizeList = new Int32Array(vertexCount);
    for (let i = 0; i < vertexCount; i++) {
      let depth = ((viewProj[2] * positions[3 * i + 0] + viewProj[6] * positions[3 * i + 1] + viewProj[10] * positions[3 * i + 2]) * 4096) | 0;
      sizeList[i] = depth;
      if (depth > maxDepth) maxDepth = depth;
      if (depth < minDepth) minDepth = depth;
    }

    // This is a 16 bit single-pass counting sort
    let depthInv = (256 * 256) / (maxDepth - minDepth);
    let counts0 = new Uint32Array(256 * 256);
    for (let i = 0; i < vertexCount; i++) {
      sizeList[i] = ((sizeList[i] - minDepth) * depthInv) | 0;
      counts0[sizeList[i]]++;
    }
    let starts0 = new Uint32Array(256 * 256);
    for (let i = 1; i < 256 * 256; i++) starts0[i] = starts0[i - 1] + counts0[i - 1];
    let depthIndex = new Uint32Array(vertexCount);
    for (let i = 0; i < vertexCount; i++) depthIndex[starts0[sizeList[i]]++] = i;

    console.timeEnd("sort");

    lastProj = viewProj;
    self.postMessage({ depthIndex, viewProj, vertexCount }, [depthIndex.buffer]);
  }

  const throttledSort = () => {
    if (!sortRunning) {
      sortRunning = true;
      let lastView = viewProj;
      runSort(lastView);
      setTimeout(() => {
        sortRunning = false;
        if (lastView !== viewProj) {
          throttledSort();
        }
      }, 0);
    }
  };

  self.onmessage = (e) => {
    if (e.data.view) {
      viewProj = e.data.view;
      throttledSort();
    } else if (e.data.positions) {
      positions = e.data.positions;
      vertexCount = positions.length / 3;
      lastVertexCount = 0;
    }
  };
}

const worker = new Worker(URL.createObjectURL(new Blob(["(" + createWorker.toString() + ")(self)"], { type: 'application/javascript' })));

worker.onmessage = (e) => {
  if (e.data.depthIndex) {
    vertexCount = e.data.depthIndex.length;
    gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, e.data.depthIndex, gl.DYNAMIC_DRAW);
    const timeEl = document.querySelector('#info p:first-child');
    timeEl.textContent = `Time: ${(e.data.viewProj[14] % 16).toFixed(2)}s / 16.00s`;
    const gaussiansEl = document.querySelector('#info p:last-child');
    gaussiansEl.textContent = `Gaussians: ${vertexCount.toLocaleString()}`;
  }
};

async function main() {
  if (!navigator.xr) {
    alert('WebXR not supported!');
    return;
  }

  const session = await navigator.xr.requestSession('immersive-ar', {
    optionalFeatures: ['dom-overlay'],
    domOverlay: { root: document.documentElement }
  });

  const canvas = document.createElement('canvas');
  gl = canvas.getContext('webgl2', { antialias: true, xrCompatible: true });
  session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

  refSpace = await session.requestReferenceSpace('local');

  const program = attachShaders(gl, vertexShaderSource, fragmentShaderSource);

  const a_position = gl.getAttribLocation(program, 'position');
  const a_index = gl.getAttribLocation(program, 'index');
  const u_projection = gl.getUniformLocation(program, 'projection');
  const u_view = gl.getUniformLocation(program, 'view');
  const u_focal = gl.getUniformLocation(program, 'focal');
  const u_viewport = gl.getUniformLocation(program, 'viewport');
  const u_time = gl.getUniformLocation(program, 'time');
  const u_texture = gl.getUniformLocation(program, 'u_texture');

  gl.enable(gl.BLEND);
  gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);

  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(a_position);
  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

  const indexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
  gl.enableVertexAttribArray(a_index);
  gl.vertexAttribIPointer(a_index, 1, gl.INT, 0, 0);
  gl.vertexAttribDivisor(a_index, 1);

  gl.bindVertexArray(null);

  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.uniform1i(u_texture, 0);

  console.log('Starting to load .splatv file...');

  // Load the specific .splatv file
  const url = './data/test401.splatv';
  const req = await fetch(url);
  console.log('Fetch completed', req.status);
  if (!req.ok) {
    alert('Failed to load .splatv file: ' + req.statusText);
    return;
  }
  const reader = req.body.getReader();

  const chunks = [{ size: 8, type: "magic" }];
  let vertexCount = 0;
  let positions = [];

  await readChunks(reader, chunks, (chunk, buffer, remaining, chunks) => {
    if (remaining) return;
    console.log('Processing chunk:', chunk.type);
    if (chunk.type === "magic") {
      const intView = new Int32Array(buffer);
      if (intView[0] !== 0x674b) throw new Error("Invalid splatv file");
      chunks.push({ size: intView[1], type: "chunks" });
    } else if (chunk.type === "chunks") {
      const splatChunks = JSON.parse(new TextDecoder("utf-8").decode(new Uint8Array(buffer)));
      if (splatChunks.length === 0) throw new Error("Invalid splatv file");
      if (splatChunks.length > 1) console.warn("Splatv file contains more than one chunk, only the first one will be loaded");
      const splatChunk = splatChunks[0];
      chunks.push(splatChunk);
    } else if (chunk.type === "splat") {
      const texdata = new Uint32Array(buffer);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32UI, chunk.texwidth, chunk.texheight, 0, gl.RGBA_INTEGER, gl.UNSIGNED_INT, texdata);
      vertexCount = (chunk.texwidth * chunk.texheight) / 4; // 4 texels per gaussian
      positions = new Float32Array(vertexCount * 3);
      // Extract positions for sorting
      for (let i = 0; i < vertexCount; i++) {
        const row = Math.floor(i / 1024);
        const col = (i % 1024) * 4;
        const texelOffset = (row * chunk.texwidth + col) * 4;
        positions[i * 3 + 0] = uintBitsToFloat(texdata[texelOffset + 0]);
        positions[i * 3 + 1] = uintBitsToFloat(texdata[texelOffset + 1]);
        positions[i * 3 + 2] = uintBitsToFloat(texdata[texelOffset + 2]);
      }
      worker.postMessage({ positions: positions });
      document.getElementById('spinner').style.display = 'none';
      document.getElementById('enter').style.display = 'block';
      console.log('Loading complete, ready to enter AR');
    }
  });

  function uintBitsToFloat(bits) {
    _floatView[0] = bits;
    return _floatView[0];
  }

  function onXRFrame(t, frame) {
    const session = frame.session;
    const pose = frame.getViewerPose(refSpace);
    if (!pose) return;

    const glLayer = session.renderState.baseLayer;
    gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Linear time over 16 seconds
    const totalDuration = 16;
    const currentTime = (Date.now() / 1000) % totalDuration;
    gl.uniform1f(u_time, currentTime);

    for (let view of pose.views) {
      const viewport = glLayer.getViewport(view);
      gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

      const projectionMatrix = view.projectionMatrix;
      gl.uniformMatrix4fv(u_projection, false, projectionMatrix);
      gl.uniform2fv(u_viewport, [viewport.width, viewport.height]);
      gl.uniform2fv(u_focal, [(projectionMatrix[0] * viewport.width) / 2, -(projectionMatrix[5] * viewport.height) / 2]);

      const viewMatrix = multiply4(view.transform.inverse.matrix, worldTransform);
      gl.uniformMatrix4fv(u_view, false, viewMatrix);

      gl.bindVertexArray(vao);
      gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, vertexCount);
      gl.bindVertexArray(null);

      const viewProj = multiply4(projectionMatrix, viewMatrix);
      worker.postMessage({ view: viewProj });
    }

    session.requestAnimationFrame(onXRFrame);
  }

  document.getElementById("enter").onclick = () => {
    session.requestAnimationFrame(onXRFrame);
  };
}

main().catch((err) => {
  console.error('Main error:', err);
  alert('Error: ' + err.message);
});

    </script>
</body>
</html>