<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSplat AR Animation Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #000;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #progress-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 100;
        }

        #progress-bar {
            width: 300px;
            height: 4px;
            background-color: #333;
            border-radius: 2px;
            overflow: hidden;
            margin: 20px auto;
        }

        #progress-fill {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: none;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            margin: 0 10px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .control-btn.active {
            background: rgba(76, 175, 80, 0.3);
            border-color: rgba(76, 175, 80, 0.5);
        }

        #ar-instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            display: none;
            z-index: 100;
        }

        .status-text {
            color: #fff;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="progress-container">
        <div>Loading GSplat Animation...</div>
        <div id="progress-bar">
            <div id="progress-fill"></div>
        </div>
        <div class="status-text" id="status-text">Initializing...</div>
    </div>

    <div id="controls">
        <button class="control-btn" id="play-btn">Play</button>
        <button class="control-btn" id="ar-btn">Start AR</button>
        <button class="control-btn" id="reset-btn">Reset View</button>
    </div>

    <div id="ar-instructions">
        <div>Point your camera at the floor and tap to place the model</div>
    </div>

    <script>
        // Global variables
        let gl, program, worker;
        let cameras = [];
        let camera = null;
        let isPlaying = false;
        let isARMode = false;
        let arSession = null;
        let arHitTestSource = null;
        let isModelPlaced = false;
        let animationStartTime = 0;
        let vertexCount = 0;
        
        // Matrices and transforms
        let viewMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        let worldTransform = [0.99, -0.05, 0.16, 0, -0.05, -1, -0.05, 0, 0.16, 0.04, -0.99, 0, -0.08, 1.63, -0.1, 1];
        
        // WebGL resources
        let texture, vertexBuffer, indexBuffer;
        
        // DOM elements
        const canvas = document.getElementById("canvas");
        const progressContainer = document.getElementById("progress-container");
        const progressFill = document.getElementById("progress-fill");
        const statusText = document.getElementById("status-text");
        const controls = document.getElementById("controls");
        const playBtn = document.getElementById("play-btn");
        const arBtn = document.getElementById("ar-btn");
        const resetBtn = document.getElementById("reset-btn");
        const arInstructions = document.getElementById("ar-instructions");

        // Vertex shader source
        const vertexShaderSource = `#version 300 es
        precision highp float;
        precision highp int;
        
        uniform highp usampler2D u_texture;
        uniform mat4 projection, view;
        uniform vec2 focal;
        uniform vec2 viewport;
        uniform float time;
        
        in vec2 position;
        in int index;
        
        out vec4 vColor;
        out vec2 vPosition;
        
        void main () {
            gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

            uvec4 motion1 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2) | 3u, uint(index) >> 10), 0);
            vec2 trbf = unpackHalf2x16(motion1.w);
            float dt = time - trbf.x;

            float topacity = exp(-1.0 * pow(dt / trbf.y, 2.0));
            if(topacity < 0.02) return;

            uvec4 motion0 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2) | 2u, uint(index) >> 10), 0);
            uvec4 static0 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2), uint(index) >> 10), 0);

            vec2 m0 = unpackHalf2x16(motion0.x), m1 = unpackHalf2x16(motion0.y), m2 = unpackHalf2x16(motion0.z), 
                 m3 = unpackHalf2x16(motion0.w), m4 = unpackHalf2x16(motion1.x); 
            
            vec4 trot = vec4(unpackHalf2x16(motion1.y).xy, unpackHalf2x16(motion1.z).xy) * dt;
            vec3 tpos = (vec3(m0.xy, m1.x) * dt + vec3(m1.y, m2.xy) * dt*dt + vec3(m3.xy, m4.x) * dt*dt*dt);
            
            vec4 cam = view * vec4(uintBitsToFloat(static0.xyz) + tpos, 1);
            vec4 pos = projection * cam;
        
            float clip = 1.2 * pos.w;
            if (pos.z < -clip || pos.x < -clip || pos.x > clip || pos.y < -clip || pos.y > clip) return;
            uvec4 static1 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2) | 1u, uint(index) >> 10), 0);

            vec4 rot = vec4(unpackHalf2x16(static0.w).xy, unpackHalf2x16(static1.x).xy) + trot;
            vec3 scale = vec3(unpackHalf2x16(static1.y).xy, unpackHalf2x16(static1.z).x);
            rot /= sqrt(dot(rot, rot));
        
            mat3 S = mat3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);
            mat3 R = mat3(
              1.0 - 2.0 * (rot.z * rot.z + rot.w * rot.w), 2.0 * (rot.y * rot.z - rot.x * rot.w), 2.0 * (rot.y * rot.w + rot.x * rot.z),
              2.0 * (rot.y * rot.z + rot.x * rot.w), 1.0 - 2.0 * (rot.y * rot.y + rot.w * rot.w), 2.0 * (rot.z * rot.w - rot.x * rot.y),
              2.0 * (rot.y * rot.w - rot.x * rot.z), 2.0 * (rot.z * rot.w + rot.x * rot.y), 1.0 - 2.0 * (rot.y * rot.y + rot.z * rot.z));
            mat3 M = S * R;
            mat3 Vrk = 4.0 * transpose(M) * M;
            mat3 J = mat3(
              focal.x / cam.z, 0., -(focal.x * cam.x) / (cam.z * cam.z), 
              0., -focal.y / cam.z, (focal.y * cam.y) / (cam.z * cam.z), 
              0., 0., 0.);
            
            mat3 T = transpose(mat3(view)) * J;
            mat3 cov2d = transpose(T) * Vrk * T;
        
            float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;
            float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));
            float lambda1 = mid + radius, lambda2 = mid - radius;
        
            if(lambda2 < 0.0) return;
            vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));
            vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
            vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);
              
            uint rgba = static1.w;
            vColor = 
                clamp(pos.z/pos.w+1.0, 0.0, 1.0) * 
                vec4(1.0, 1.0, 1.0, topacity) *
                vec4(
                    (rgba) & 0xffu, 
                    (rgba >> 8) & 0xffu, 
                    (rgba >> 16) & 0xffu, 
                    (rgba >> 24) & 0xffu) / 255.0;

            vec2 vCenter = vec2(pos) / pos.w;
            gl_Position = vec4(
                vCenter 
                + position.x * majorAxis / viewport 
                + position.y * minorAxis / viewport, 0.0, 1.0);

            vPosition = position;
        }`;

        // Fragment shader source
        const fragmentShaderSource = `#version 300 es
        precision highp float;
        
        in vec4 vColor;
        in vec2 vPosition;
        
        out vec4 fragColor;
        
        void main () {
            float A = -dot(vPosition, vPosition);
            if (A < -4.0) discard;
            float B = exp(A) * vColor.a;
            fragColor = vec4(B * vColor.rgb, B);
        }`;

        // Initialize WebGL and load model
        async function init() {
            try {
                statusText.textContent = "Setting up WebGL...";
                setupWebGL();
                
                statusText.textContent = "Loading animation data...";
                await loadSplatvFile();
                
                statusText.textContent = "Setting up controls...";
                setupEventListeners();
                
                // Hide progress and show controls
                progressContainer.style.display = "none";
                controls.style.display = "block";
                
                // Start render loop
                startRenderLoop();
                
            } catch (error) {
                console.error("Initialization failed:", error);
                statusText.textContent = "Failed to load. Please refresh the page.";
            }
        }

        // Setup WebGL context and shaders
        function setupWebGL() {
            gl = canvas.getContext("webgl2", { antialias: true });
            if (!gl) {
                throw new Error("WebGL2 not supported");
            }

            program = attachShaders(gl, vertexShaderSource, fragmentShaderSource);
            
            // Setup WebGL state
            gl.disable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFuncSeparate(gl.ONE_MINUS_DST_ALPHA, gl.ONE, gl.ONE_MINUS_DST_ALPHA, gl.ONE);
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);

            // Create buffers
            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-2, -2, 2, -2, 2, 2, -2, 2]), gl.STATIC_DRAW);

            indexBuffer = gl.createBuffer();
            texture = gl.createTexture();

            // Setup worker for sorting
            setupWorker();
        }

        // Setup web worker for depth sorting
        function setupWorker() {
            const workerCode = `
                let buffer;
                let vertexCount = 0;

                self.onmessage = function (e) {
                    if (e.data.texture) {
                        buffer = e.data.texture;
                        vertexCount = e.data.texture.length / 16;
                        postMessage({ vertexCount: vertexCount });
                    } else if (e.data.viewProj) {
                        const viewProj = new Float32Array(e.data.viewProj);
                        const depthInv = new Float32Array(vertexCount);
                        const depthIndex = new Uint32Array(vertexCount);
                        const sizeList = new Int32Array(vertexCount);

                        for (let i = 0; i < vertexCount; i++) {
                            const o0 = buffer[i * 16 + 0];
                            const o1 = buffer[i * 16 + 1]; 
                            const o2 = buffer[i * 16 + 2];

                            const x = (o0 & 0xFFFFu) * (2 / 65535) - 1;
                            const y = ((o0 >> 16) & 0xFFFFu) * (2 / 65535) - 1;
                            const z = (o1 & 0xFFFFu) * (2 / 65535) - 1;

                            const depth = 4 * (viewProj[2] * x + viewProj[6] * y + viewProj[10] * z + viewProj[14]);
                            depthInv[i] = -depth;
                            sizeList[i] = (sizeList[i] * depthInv[i]) | 0;
                        }

                        const depthIndexSort = Array.from({length: vertexCount}, (_, i) => i);
                        depthIndexSort.sort((a, b) => depthInv[a] - depthInv[b]);
                        
                        for (let i = 0; i < vertexCount; i++) {
                            depthIndex[i] = depthIndexSort[i];
                        }

                        postMessage({ depthIndex, viewProj: e.data.viewProj, vertexCount });
                    }
                };
            `;

            const blob = new Blob([workerCode], { type: "application/javascript" });
            worker = new Worker(URL.createObjectURL(blob));
            
            worker.onmessage = (e) => {
                if (e.data.depthIndex) {
                    const { depthIndex } = e.data;
                    gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, depthIndex, gl.DYNAMIC_DRAW);
                    vertexCount = e.data.vertexCount;
                }
            };
        }

        // Load splatv file using the same method as hybrid.js
        async function loadSplatvFile() {
            const url = "https://raw.githubusercontent.com/lumigrade/LumiAR/main/data/test401.splatv";
            const response = await fetch(url, { mode: "cors", credentials: "omit" });
            
            if (response.status !== 200) {
                throw new Error(`${response.status} Unable to load ${url}`);
            }

            let loadedBytes = 0;
            const contentLength = parseInt(response.headers.get('content-length') || '0', 10);

            await readChunks(response.body.getReader(), [{ size: 8, type: "magic" }], chunkHandler);
            
            function chunkHandler(chunk, buffer, remaining, chunks) {
                loadedBytes += buffer.length;
                if (contentLength > 0) {
                    const progress = (loadedBytes / contentLength) * 100;
                    progressFill.style.width = `${Math.min(progress, 100)}%`;
                }

                if (!remaining && chunk.type === "magic") {
                    let intView = new Uint32Array(buffer.buffer);
                    if (intView[0] !== 0x674b) throw new Error("This does not look like a splatv file");
                    chunks.push({ size: intView[1], type: "chunks" });
                } else if (!remaining && chunk.type === "chunks") {
                    for (let chunk of JSON.parse(new TextDecoder("utf-8").decode(buffer))) {
                        chunks.push(chunk);
                        if (chunk.type === "splat") {
                            cameras = chunk.cameras;
                            camera = chunk.cameras[0];
                            resize();
                        }
                    }
                } else if (chunk.type === "splat") {
                    vertexCount = Math.floor(buffer.byteLength / 64); // 64 bytes per gaussian
                    worker.postMessage({ texture: new Float32Array(buffer), remaining: remaining });
                    
                    const texdata = new Uint32Array(buffer);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32UI, chunk.texwidth, chunk.texheight, 0, gl.RGBA_INTEGER, gl.UNSIGNED_INT, texdata);
                }
            }
        }

        // Read chunks from stream (from hybrid.js)
        async function readChunks(reader, chunks, handleChunk) {
            let chunk = chunks.shift();
            let buffer = new Uint8Array(chunk.size);
            let offset = 0;
            while (chunk) {
                let { done, value } = await reader.read();
                if (done) break;
                buffer.set(value.subarray(0, Math.min(value.length, chunk.size - offset)), offset);
                let total = offset + value.length;
                if (total >= chunk.size) {
                    handleChunk(chunk, buffer, total - chunk.size, chunks);
                    let nextChunk = chunks.shift();
                    if (nextChunk) {
                        let leftover = total - chunk.size;
                        chunk = nextChunk;
                        buffer = new Uint8Array(chunk.size);
                        if (leftover > 0) {
                            buffer.set(value.subarray(value.length - leftover, value.length), 0);
                            offset = leftover;
                        } else {
                            offset = 0;
                        }
                    } else {
                        break;
                    }
                } else {
                    offset = total;
                }
            }
        }

        // Setup shaders (from hybrid.js)
        function attachShaders(gl, vertexShaderSource, fragmentShaderSource) {
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(vertexShader));
            }

            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(fragmentShader));
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
            }
            return program;
        }

        // Handle window resize
        function resize() {
            if (!camera || isARMode) return;
            
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);

            const focal = [
                (camera.fx / 1) * canvas.width / camera.width,
                (camera.fy / 1) * canvas.height / camera.height
            ];

            const projectionMatrix = getProjectionMatrix(
                camera.fx / 1, camera.fy / 1, canvas.width, canvas.height
            );

            const u_projection = gl.getUniformLocation(program, "projection");
            const u_viewport = gl.getUniformLocation(program, "viewport");
            const u_focal = gl.getUniformLocation(program, "focal");

            gl.uniformMatrix4fv(u_projection, false, projectionMatrix);
            gl.uniform2fv(u_viewport, new Float32Array([canvas.width, canvas.height]));
            gl.uniform2fv(u_focal, new Float32Array(focal));
        }

        // Get projection matrix
        function getProjectionMatrix(fx, fy, width, height) {
            return new Float32Array([
                2 * fx / width, 0, 0, 0,
                0, -2 * fy / height, 0, 0,
                0, 0, -1, -1,
                0, 0, -0.2, 0
            ]);
        }

        // Setup event listeners
        function setupEventListeners() {
            playBtn.addEventListener('click', togglePlayback);
            arBtn.addEventListener('click', toggleAR);
            resetBtn.addEventListener('click', resetView);
            
            window.addEventListener('resize', resize);
            
            // Mouse controls for 6DOF
            let mouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            
            canvas.addEventListener('mousedown', (e) => {
                if (!isARMode) {
                    mouseDown = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (mouseDown && !isARMode) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    rotateView(deltaX * 0.01, deltaY * 0.01);
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            canvas.addEventListener('wheel', (e) => {
                if (!isARMode) {
                    e.preventDefault();
                    zoomView(e.deltaY * 0.001);
                }
            });

            // Check AR support
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then(supported => {
                    if (!supported) {
                        arBtn.style.display = 'none';
                    }
                }).catch(() => arBtn.style.display = 'none');
            } else {
                arBtn.style.display = 'none';
            }
        }

        // Simple view rotation
        function rotateView(deltaX, deltaY) {
            // Basic rotation matrix manipulation
            const cosX = Math.cos(deltaX);
            const sinX = Math.sin(deltaX);
            const cosY = Math.cos(deltaY);
            const sinY = Math.sin(deltaY);
            
            // Apply horizontal rotation
            const m00 = worldTransform[0] * cosX - worldTransform[8] * sinX;
            const m08 = worldTransform[0] * sinX + worldTransform[8] * cosX;
            const m02 = worldTransform[2] * cosX - worldTransform[10] * sinX;
            const m10 = worldTransform[2] * sinX + worldTransform[10] * cosX;
            
            worldTransform[0] = m00;
            worldTransform[8] = m08;
            worldTransform[2] = m02;
            worldTransform[10] = m10;
        }

        // Simple view zoom
        function zoomView(delta) {
            worldTransform[14] += delta;
        }

        // Toggle playback
        function togglePlayback() {
            isPlaying = !isPlaying;
            playBtn.textContent = isPlaying ? 'Pause' : 'Play';
            playBtn.classList.toggle('active', isPlaying);
            
            if (isPlaying) {
                animationStartTime = performance.now();
            }
        }

        // Toggle AR mode
        async function toggleAR() {
            if (!isARMode) {
                await startAR();
            } else {
                await stopAR();
            }
        }

        // Start AR session
        async function startAR() {
            try {
                arSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test', 'local'],
                    optionalFeatures: ['dom-overlay'],
                    domOverlay: { root: document.body }
                });

                await gl.makeXRCompatible();
                arSession.updateRenderState({ baseLayer: new XRWebGLLayer(arSession, gl) });
                
                const refSpace = await arSession.requestReferenceSpace('local');
                const hitTestSpace = await arSession.requestReferenceSpace('viewer');
                arHitTestSource = await arSession.requestHitTestSource({ space: hitTestSpace });

                isARMode = true;
                isModelPlaced = false;
                arBtn.textContent = 'Exit AR';
                arBtn.classList.add('active');
                arInstructions.style.display = 'block';

                arSession.addEventListener('end', stopAR);
                arSession.addEventListener('selectstart', onARSelect);
                
                arSession.requestAnimationFrame(onARFrame);

            } catch (error) {
                console.error('Failed to start AR:', error);
                alert('AR failed to start. Make sure you\'re on a supported device.');
            }
        }

        // Stop AR session
        async function stopAR() {
            if (arSession) {
                await arSession.end();
            }
            
            isARMode = false;
            isModelPlaced = false;
            arSession = null;
            arHitTestSource = null;
            
            arBtn.textContent = 'Start AR';
            arBtn.classList.remove('active');
            arInstructions.style.display = 'none';
        }

        // Handle AR selection
        function onARSelect() {
            if (!isModelPlaced && arHitTestSource) {
                isModelPlaced = true;
                arInstructions.style.display = 'none';
            }
        }

        // AR frame rendering
        function onARFrame(time, frame) {
            const session = frame.session;
            const pose = frame.getViewerPose(session.requestReferenceSpace('local'));
            
            if (!pose) {
                session.requestAnimationFrame(onARFrame);
                return;
            }

            const layer = session.renderState.baseLayer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, layer.framebuffer);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Calculate animation time
            const animTime = isPlaying ? (performance.now() - animationStartTime) / 1000 : 0;
            const u_time = gl.getUniformLocation(program, "time");
            gl.uniform1f(u_time, animTime);

            // Handle hit testing for placement
            if (!isModelPlaced && arHitTestSource) {
                const hitTestResults = frame.getHitTestResults(arHitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const hitPose = hit.getPose(pose.transform);
                    worldTransform = Array.from(hitPose.transform.matrix);
                }
            }

            // Render for each view
            for (const view of pose.views) {
                const viewport = layer.getViewport(view);
                gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

                const projectionMatrix = view.projectionMatrix;