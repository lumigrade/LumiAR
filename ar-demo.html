<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSplat AR Animation Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #000;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #progress-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 100;
        }

        #progress-bar {
            width: 300px;
            height: 4px;
            background-color: #333;
            border-radius: 2px;
            overflow: hidden;
            margin: 20px auto;
        }

        #progress-fill {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: none;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            margin: 0 10px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .control-btn.active {
            background: rgba(76, 175, 80, 0.3);
            border-color: rgba(76, 175, 80, 0.5);
        }

        #ar-instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            display: none;
            z-index: 100;
        }

        #preview-model {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            display: none;
            z-index: 50;
            backdrop-filter: blur(5px);
        }

        .status-text {
            color: #fff;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="progress-container">
        <div>Loading GSplat Animation...</div>
        <div id="progress-bar">
            <div id="progress-fill"></div>
        </div>
        <div class="status-text" id="status-text">Initializing...</div>
    </div>

    <div id="controls">
        <button class="control-btn" id="play-btn">Play</button>
        <button class="control-btn" id="ar-btn">Start AR</button>
        <button class="control-btn" id="reset-btn">Reset View</button>
    </div>

    <div id="ar-instructions">
        <div>Point your camera at the floor and tap to place the model</div>
    </div>

    <div id="preview-model">
        <div style="text-align: center; line-height: 196px; color: rgba(255,255,255,0.7);">
            Preview Model
        </div>
    </div>

    <script type="module">
        import { 
            Scene, 
            Camera, 
            WebGLRenderer, 
            VideoRenderProgram,
            SplatvLoader, 
            Splatv,
            OrbitControls,
            Vector3,
            Quaternion
        } from "https://cdn.jsdelivr.net/npm/gsplat@latest/dist/index.js";

        // Global variables
        let scene, camera, renderer, orbitControls;
        let splatvData = null;
        let isPlaying = false;
        let isARMode = false;
        let arSession = null;
        let arHitTestSource = null;
        let isModelPlaced = false;
        let modelTransform = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        let animationStartTime = 0;
        const targetFPS = 25;
        const frameDuration = 1000 / targetFPS; // 40ms per frame

        // DOM elements
        const canvas = document.getElementById("canvas");
        const progressContainer = document.getElementById("progress-container");
        const progressFill = document.getElementById("progress-fill");
        const statusText = document.getElementById("status-text");
        const controls = document.getElementById("controls");
        const playBtn = document.getElementById("play-btn");
        const arBtn = document.getElementById("ar-btn");
        const resetBtn = document.getElementById("reset-btn");
        const arInstructions = document.getElementById("ar-instructions");
        const previewModel = document.getElementById("preview-model");

        // Initialize the application
        async function init() {
            try {
                statusText.textContent = "Setting up renderer...";
                
                // Create scene and camera
                scene = new Scene();
                camera = new Camera();
                
                // Setup camera for non-AR view
                camera.data.setSize(canvas.clientWidth, canvas.clientHeight);
                camera.position = new Vector3(0, 1, 3);

                // Create renderer with VideoRenderProgram for splatv animation
                renderer = new WebGLRenderer(canvas);
                renderer.addProgram(new VideoRenderProgram(renderer));

                statusText.textContent = "Loading animation data...";
                await loadSplatvAnimation();
                
                statusText.textContent = "Setting up controls...";
                setupControls();
                setupEventListeners();
                
                // Hide progress and show controls
                progressContainer.style.display = "none";
                controls.style.display = "block";
                
                // Start render loop
                startRenderLoop();
                
            } catch (error) {
                console.error("Initialization failed:", error);
                statusText.textContent = "Failed to load. Please refresh the page.";
            }
        }

        // Load splatv animation file
        async function loadSplatvAnimation() {
            try {
                const loader = new SplatvLoader();
                // Use the correct GitHub raw URL
                const url = "https://raw.githubusercontent.com/lumigrade/LumiAR/main/data/test401.splatv";
                
                // Load with progress tracking
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to load ${url}: ${response.status}`);
                }
                
                const total = parseInt(response.headers.get('content-length'), 10) || 1;
                let loaded = 0;
                
                const reader = response.body.getReader();
                const chunks = [];
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    chunks.push(value);
                    loaded += value.length;
                    
                    const progress = (loaded / total) * 100;
                    progressFill.style.width = `${Math.min(progress, 100)}%`;
                }
                
                // Combine chunks and parse
                const arrayBuffer = new Uint8Array(loaded);
                let offset = 0;
                for (const chunk of chunks) {
                    arrayBuffer.set(chunk, offset);
                    offset += chunk.length;
                }
                
                statusText.textContent = "Parsing animation...";
                
                // Load splatv data
                splatvData = await loader.loadFromArrayBuffer(arrayBuffer.buffer);
                const splat = new Splatv(splatvData);
                scene.addObject(splat);
                
                console.log("Loaded splatv animation with", splatvData.vertexCount, "gaussians");
                
            } catch (error) {
                console.error("Error loading splatv:", error);
                throw error;
            }
        }

        // Setup orbit controls for non-AR mode
        function setupControls() {
            orbitControls = new OrbitControls(camera, canvas);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.target.set(0, 0, 0);
        }

        // Setup event listeners
        function setupEventListeners() {
            playBtn.addEventListener('click', togglePlayback);
            arBtn.addEventListener('click', toggleAR);
            resetBtn.addEventListener('click', resetView);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Handle AR session events
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then(supported => {
                    if (!supported) {
                        arBtn.style.display = 'none';
                        console.log("AR not supported on this device");
                    }
                }).catch(console.error);
            } else {
                arBtn.style.display = 'none';
            }
        }

        // Toggle playback
        function togglePlayback() {
            isPlaying = !isPlaying;
            playBtn.textContent = isPlaying ? 'Pause' : 'Play';
            playBtn.classList.toggle('active', isPlaying);
            
            if (isPlaying) {
                animationStartTime = performance.now();
            }
        }

        // Toggle AR mode
        async function toggleAR() {
            if (!isARMode) {
                await startAR();
            } else {
                await stopAR();
            }
        }

        // Start AR session
        async function startAR() {
            try {
                arSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test', 'local'],
                    optionalFeatures: ['dom-overlay'],
                    domOverlay: { root: document.body }
                });

                // Setup XR-compatible context
                const gl = canvas.getContext('webgl2', { xrCompatible: true });
                await gl.makeXRCompatible();

                // Setup XR session
                arSession.updateRenderState({ baseLayer: new XRWebGLLayer(arSession, gl) });
                
                const refSpace = await arSession.requestReferenceSpace('local');
                const hitTestSpace = await arSession.requestReferenceSpace('viewer');
                arHitTestSource = await arSession.requestHitTestSource({ space: hitTestSpace });

                isARMode = true;
                isModelPlaced = false;
                arBtn.textContent = 'Exit AR';
                arBtn.classList.add('active');
                arInstructions.style.display = 'block';
                previewModel.style.display = 'block';

                // Handle session end
                arSession.addEventListener('end', () => {
                    stopAR();
                });

                // Handle tap to place
                arSession.addEventListener('selectstart', onARSelect);
                
                // Start AR render loop
                arSession.requestAnimationFrame(onARFrame);

            } catch (error) {
                console.error('Failed to start AR:', error);
                alert('AR failed to start. Make sure you\'re on a supported device.');
            }
        }

        // Stop AR session
        async function stopAR() {
            if (arSession) {
                await arSession.end();
            }
            
            isARMode = false;
            isModelPlaced = false;
            arSession = null;
            arHitTestSource = null;
            
            arBtn.textContent = 'Start AR';
            arBtn.classList.remove('active');
            arInstructions.style.display = 'none';
            previewModel.style.display = 'none';
        }

        // Handle AR select (tap to place)
        function onARSelect(event) {
            if (!isModelPlaced && arHitTestSource) {
                isModelPlaced = true;
                arInstructions.style.display = 'none';
                previewModel.style.display = 'none';
            }
        }

        // AR frame handler
        function onARFrame(time, frame) {
            const session = frame.session;
            const pose = frame.getViewerPose(session.requestReferenceSpace('local'));
            
            if (!pose) {
                session.requestAnimationFrame(onARFrame);
                return;
            }

            const gl = session.renderState.baseLayer.context;
            const layer = session.renderState.baseLayer;

            gl.bindFramebuffer(gl.FRAMEBUFFER, layer.framebuffer);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Handle hit testing for placement
            if (!isModelPlaced && arHitTestSource) {
                const hitTestResults = frame.getHitTestResults(arHitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const hitMatrix = hit.getPose(pose.transform).transform.matrix;
                    // Store hit position for model placement
                    modelTransform = Array.from(hitMatrix);
                }
            }

            // Render for each view (eye)
            for (const view of pose.views) {
                const viewport = layer.getViewport(view);
                gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

                // Update camera matrices for AR
                const viewMatrix = view.transform.inverse.matrix;
                const projectionMatrix = view.projectionMatrix;
                
                // Update time for animation
                const currentTime = isPlaying ? (performance.now() - animationStartTime) / frameDuration : 0;
                
                // Render the splat with AR camera
                if (splatvData && isModelPlaced) {
                    renderSplatInAR(gl, viewMatrix, projectionMatrix, modelTransform, currentTime);
                }
            }

            session.requestAnimationFrame(onARFrame);
        }

        // Render splat in AR context
        function renderSplatInAR(gl, viewMatrix, projectionMatrix, modelMatrix, time) {
            // This would integrate with GSplat's VideoRenderProgram
            // For now, we'll use a simplified approach
            if (renderer.renderProgram && renderer.renderProgram.render) {
                // Update camera matrices
                camera.data.projectionMatrix.set(projectionMatrix);
                camera.data.viewMatrix.set(viewMatrix);
                
                // Apply model transform
                // This might need adjustment based on GSplat's coordinate system
                
                // Render with time parameter for animation
                renderer.renderProgram.render(time);
            }
        }

        // Reset view to default
        function resetView() {
            if (orbitControls && !isARMode) {
                orbitControls.reset();
                camera.position = new Vector3(0, 1, 3);
                camera.rotation = Quaternion.FromEuler(new Vector3(0, 0, 0));
            }
        }

        // Handle window resize
        function onWindowResize() {
            if (!isARMode) {
                camera.data.setSize(canvas.clientWidth, canvas.clientHeight);
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            }
        }

        // Main render loop for non-AR mode
        function startRenderLoop() {
            function render(currentTime) {
                if (!isARMode) {
                    if (orbitControls) {
                        orbitControls.update();
                    }
                    
                    // Calculate animation time
                    const animTime = isPlaying ? (currentTime - animationStartTime) / frameDuration : 0;
                    
                    // Render the scene
                    if (renderer && renderer.render) {
                        renderer.render(scene, camera);
                    }
                }
                
                requestAnimationFrame(render);
            }
            
            requestAnimationFrame(render);
        }

        // Start the application
        init().catch(console.error);
    </script>
</body>
</html>