<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üé≠ 4DVV .splatv AR - 4D Gaussian Splatting</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #controls { position: absolute; top: 10px; left: 10px; z-index: 10; }
        button { margin: 5px; padding: 8px 12px; }
        #info { position: absolute; bottom: 10px; left: 10px; z-index: 10; color: white; background: rgba(0,0,0,0.5); padding: 10px; }
        #spinner { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #enter { display: none; }
    </style>
</head>
<body>
    <div id="spinner">Loading gsplat.js VideoRenderProgram...</div>
    <button id="enter">Enter AR</button>

    <div id="controls">
        <div>
            <button>üìÅ Load</button>
            <button>üß™ Original</button>
            <button>üîß Fixed</button>
            <button>‚úÖ Example</button>
            <button>‚¨áÔ∏è Download</button>
        </div>
        <div>
            <button>‚ñ∂Ô∏è Play</button>
            <button>üöÄ AR</button>
        </div>
    </div>

    <div id="info">
        <p>Time: 0.00s / 16.00s</p>
        <p>Gaussians: 0</p>
    </div>

    <script>
        let refSpace;
        let gl;

        let worldTransform = [0.99, -0.05, 0.16, 0, -0.05, -1, -0.05, 0, 0.16, 0.04, -0.99, 0, -0.08, 1.63, -0.1, 1];

        const params = new URLSearchParams(location.search);
        try {
          worldTransform = JSON.parse(decodeURIComponent(location.hash.slice(1)));
        } catch (err) {}

        const vertexShaderSource = `
          #version 300 es
          precision highp float;
          precision highp int;
          
          uniform highp usampler2D u_texture;
          uniform mat4 projection, view;
          uniform vec2 focal;
          uniform vec2 viewport;
          uniform float time;
          
          in vec2 position;
          in int index;
          
          out vec4 vColor;
          out vec2 vPosition;
          
          void main () {
              gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

              uvec4 motion1 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2) | 3u, uint(index) >> 10), 0);
              vec2 trbf = unpackHalf2x16(motion1.w);
              float dt = time - trbf.x;

              float topacity = exp(-1.0 * pow(dt / trbf.y, 2.0));
              if(topacity < 0.02) return;

              uvec4 motion0 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2) | 2u, uint(index) >> 10), 0);
              uvec4 static0 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2), uint(index) >> 10), 0);

              vec2 m0 = unpackHalf2x16(motion0.x), m1 = unpackHalf2x16(motion0.y), m2 = unpackHalf2x16(motion0.z), 
                   m3 = unpackHalf2x16(motion0.w), m4 = unpackHalf2x16(motion1.x); 
              
              vec4 trot = vec4(unpackHalf2x16(motion1.y).xy, unpackHalf2x16(motion1.z).xy) * dt;
              vec3 tpos = (vec3(m0.xy, m1.x) * dt + vec3(m1.y, m2.xy) * dt*dt + vec3(m3.xy, m4.x) * dt*dt*dt);
              
              vec4 cam = view * vec4(uintBitsToFloat(static0.xyz) + tpos, 1);
              vec4 pos = projection * cam;
          
              float clip = 1.2 * pos.w;
              if (pos.z < -clip || pos.x < -clip || pos.x > clip || pos.y < -clip || pos.y > clip) return;
              uvec4 static1 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 2) | 1u, uint(index) >> 10), 0);

              vec4 rot = vec4(unpackHalf2x16(static0.w).xy, unpackHalf2x16(static1.x).xy) + trot;
              vec3 scale = vec3(unpackHalf2x16(static1.y).xy, unpackHalf2x16(static1.z).x);
              rot /= sqrt(dot(rot, rot));
          
              mat3 S = mat3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);
              mat3 R = mat3(
                1.0 - 2.0 * (rot.z * rot.z + rot.w * rot.w), 2.0 * (rot.y * rot.z - rot.x * rot.w), 2.0 * (rot.y * rot.w + rot.x * rot.z),
                2.0 * (rot.y * rot.z + rot.x * rot.w), 1.0 - 2.0 * (rot.y * rot.y + rot.w * rot.w), 2.0 * (rot.z * rot.w - rot.x * rot.y),
                2.0 * (rot.y * rot.w - rot.x * rot.z), 2.0 * (rot.z * rot.w + rot.x * rot.y), 1.0 - 2.0 * (rot.y * rot.y + rot.z * rot.z));
              mat3 M = S * R;
              mat3 Vrk = 4.0 * transpose(M) * M;
              mat3 J = mat3(
                focal.x / cam.z, 0., -(focal.x * cam.x) / (cam.z * cam.z), 
                0., -focal.y / cam.z, (focal.y * cam.y) / (cam.z * cam.z), 
                0., 0., 0.
            );
          
              mat3 T = transpose(mat3(view)) * J;
              mat3 cov2d = transpose(T) * Vrk * T;
          
              float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;
              float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));
              float lambda1 = mid + radius, lambda2 = mid - radius;
          
              if(lambda2 < 0.0) return;
              vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));
              vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
              vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);
              
              uint rgba = static1.w;
              vColor = 
                clamp(pos.z/pos.w+1.0, 0.0, 1.0) * 
                vec4(1.0, 1.0, 1.0, topacity) *
                vec4(
                  (rgba) & 0xffu, 
                  (rgba >> 8) & 0xffu, 
                  (rgba >> 16) & 0xffu, 
                  (rgba >> 24) & 0xffu) / 255.0;

              vec2 vCenter = vec2(pos) / pos.w;
              gl_Position = vec4(
                  vCenter 
                  + position.x * majorAxis / viewport 
                  + position.y * minorAxis / viewport, 0.0, 1.0);

              vPosition = position;
          }
          `.trim();

        const fragmentShaderSource = `
          #version 300 es
          precision highp float;
          
          in vec4 vColor;
          in vec2 vPosition;
          
          out vec4 fragColor;
          
          void main () {
              float A = -dot(vPosition, vPosition);
              if (A < -4.0) discard;
              float B = exp(A) * vColor.a;
              fragColor = vec4(B * vColor.rgb, B);
          }
          
          `.trim();

        const vertices = [
          -2.0, -2.0,
          2.0, -2.0,
          0.0,  2.0
        ];

        async function main() {
          if (!navigator.xr) {
            alert('WebXR not supported!');
            return;
          }

          const session = await navigator.xr.requestSession('immersive-ar', {
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.documentElement }
          });

          const canvas = document.createElement('canvas');
          gl = canvas.getContext('webgl2', { antialias: true, xrCompatible: true });
          session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

          refSpace = await session.requestReferenceSpace('local');

          const program = attachShaders(gl, vertexShaderSource, fragmentShaderSource);

          const a_position = gl.getAttribLocation(program, 'position');
          const a_index = gl.getAttribLocation(program, 'index');
          const u_projection = gl.getUniformLocation(program, 'projection');
          const u_view = gl.getUniformLocation(program, 'view');
          const u_focal = gl.getUniformLocation(program, 'focal');
          const u_viewport = gl.getUniformLocation(program, 'viewport');
          const u_time = gl.getUniformLocation(program, 'time');
          const u_texture = gl.getUniformLocation(program, 'u_texture');

          gl.enable(gl.BLEND);
          gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);

          const vao = gl.createVertexArray();
          gl.bindVertexArray(vao);

          const positionBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(a_position);
          gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

          const indexBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
          gl.enableVertexAttribArray(a_index);
          gl.vertexAttribIPointer(a_index, 1, gl.INT, 0, 0);
          gl.vertexAttribDivisor(a_index, 1);

          gl.bindVertexArray(null);

          const worker = new Worker(URL.createObjectURL(new Blob(["(" + createWorker.toString() + ")(self)"], { type: 'application/javascript' })));

          worker.onmessage = (e) => {
            if (e.data.depthIndex) {
              vertexCount = e.data.depthIndex.length;
              gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, e.data.depthIndex, gl.DYNAMIC_DRAW);
              document.getElementById('info').innerHTML = `
                <p>Time: ${(e.data.viewProj[14] % 16).toFixed(2)}s / 16.00s</p>
                <p>Gaussians: ${vertexCount.toLocaleString()}</p>
              `;
            }
          };

          const texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.uniform1i(u_texture, 0);

          // Load the specific .splatv file
          const url = './data/test401.splatv';
          const req = await fetch(url);
          const reader = req.body.getReader();

          const chunks = [{ size: 8, type: "magic" }];
          await readChunks(reader, chunks, (chunk, buffer, remaining, chunks) => {
            if (remaining) return;
            if (chunk.type === "magic") {
              const intView = new Int32Array(buffer);
              if (intView[0] !== 0x674b) throw new Error("Invalid splatv file");
              chunks.push({ size: intView[1], type: "chunks" });
            } else if (chunk.type === "chunks") {
              const splatChunks = JSON.parse(new TextDecoder("utf-8").decode(new Uint8Array(buffer)));
              if (splatChunks.length === 0) throw new Error("Invalid splatv file");
              if (splatChunks.length > 1) console.warn("Splatv file contains more than one chunk, only the first one will be loaded");
              const splatChunk = splatChunks[0];
              chunks.push(splatChunk);
            } else if (chunk.type === "splat") {
              const texdata = new Uint32Array(buffer);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32UI, chunk.texwidth, chunk.texheight, 0, gl.RGBA_INTEGER, gl.UNSIGNED_INT, texdata);
              worker.postMessage({ texture: true, texwidth: chunk.texwidth, texheight: chunk.texheight });
            }
          });

          session.requestAnimationFrame(onXRFrame);

          function onXRFrame(t, frame) {
            const session = frame.session;
            const pose = frame.getViewerPose(refSpace);
            if (!pose) return;

            const glLayer = session.renderState.baseLayer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Linear time over 16 seconds
            const totalDuration = 16;
            const currentTime = (Date.now() / 1000) % totalDuration;
            gl.uniform1f(u_time, currentTime);

            for (let view of pose.views) {
              const viewport = glLayer.getViewport(view);
              gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

              const projectionMatrix = view.projectionMatrix;
              gl.uniformMatrix4fv(u_projection, false, projectionMatrix);
              gl.uniform2fv(u_viewport, [viewport.width, viewport.height]);
              gl.uniform2fv(u_focal, [(projectionMatrix[0] * viewport.width) / 2, -(projectionMatrix[5] * viewport.height) / 2]);

              const viewMatrix = multiply4(view.transform.inverse.matrix, worldTransform);
              gl.uniformMatrix4fv(u_view, false, viewMatrix);

              gl.bindVertexArray(vao);
              gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, vertexCount);
              gl.bindVertexArray(null);

              const viewProj = multiply4(projectionMatrix, viewMatrix);
              worker.postMessage({ view: viewProj });
            }

            session.requestAnimationFrame(onXRFrame);
          }
        }

        main().catch(console.error);
    </script>
</body>
</html>