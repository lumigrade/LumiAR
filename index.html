<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé≠ AR Splat Sequence Demo - Single Sequence Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            overflow-x: hidden;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 18px;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 12px;
            opacity: 0.7;
        }

        .status {
            position: fixed;
            top: 80px;
            left: 20px;
            right: 20px;
            z-index: 150;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .status.success {
            background: rgba(46, 204, 113, 0.8);
            border: 1px solid rgba(46, 204, 113, 0.3);
        }

        .status.error {
            background: rgba(231, 76, 60, 0.8);
            border: 1px solid rgba(231, 76, 60, 0.3);
        }

        .status.info {
            background: rgba(52, 152, 219, 0.8);
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #3498db;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            touch-action: none;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .main-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-btn {
            padding: 12px 20px;
            background: rgba(52, 152, 219, 0.9);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .control-btn:hover {
            background: rgba(52, 152, 219, 1);
            transform: scale(1.05);
        }

        .control-btn:disabled {
            background: rgba(127, 140, 141, 0.5);
            cursor: not-allowed;
            transform: none;
        }

        .ar-button {
            background: rgba(46, 204, 113, 0.9);
        }

        .ar-button:hover {
            background: rgba(46, 204, 113, 1);
        }

        .device-info {
            position: fixed;
            top: 130px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 5px;
            font-size: 10px;
            font-family: monospace;
            z-index: 100;
            max-width: 200px;
        }

        .playback-info {
            position: fixed;
            top: 130px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 5px;
            font-size: 10px;
            font-family: monospace;
            z-index: 100;
            display: none;
        }

        .playback-info.visible {
            display: block;
        }

        .gesture-hint {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 90;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            display: none;
        }

        .gesture-hint.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé≠ AR Splat Sequence Demo - Single Test</h1>
        <p>Testing ./data/splat/ sequence (400 frames)</p>
    </div>

    <div class="status" id="status">Initializing AR Splat System...</div>
    
    <div class="device-info" id="deviceInfo">
        Device Info Loading...
    </div>

    <div class="playback-info" id="playbackInfo">
        <div>Frame: <span id="currentFrame">0</span>/<span id="totalFrames">0</span></div>
        <div>FPS: <span id="currentFPS">0</span></div>
        <div>Memory: <span id="memoryUsage">0</span> MB</div>
        <div>Buffer: <span id="bufferSize">0</span></div>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div id="loadingText">Initializing gsplat.js...</div>
    </div>

    <canvas id="canvas3d"></canvas>

    <div class="controls">
        <div class="main-controls">
            <button class="control-btn" id="loadSequenceBtn" onclick="loadSplatSequence()">üé¨ Load Sequence</button>
            <button class="control-btn" id="playBtn" onclick="togglePlayback()" disabled>‚ñ∂Ô∏è Play</button>
            <button class="ar-button control-btn" id="arBtn" onclick="startAR()" disabled>üöÄ AR Mode</button>
        </div>
    </div>

    <div class="gesture-hint" id="gestureHint">
        üëÜ Tap to place ‚Ä¢ ‚úã Two fingers to scale & rotate
    </div>

    <script type="module">
        // Global variables
        let SPLAT = null;
        let scene, camera, renderer, controls;
        let deviceCapabilities = {};
        let currentSplatPlayer = null;
        let isARMode = false;
        let currentSplat = null;

        // DOM elements
        const canvas = document.getElementById('canvas3d');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const deviceInfo = document.getElementById('deviceInfo');
        const playbackInfo = document.getElementById('playbackInfo');
        const gestureHint = document.getElementById('gestureHint');
        const loadSequenceBtn = document.getElementById('loadSequenceBtn');
        const playBtn = document.getElementById('playBtn');
        const arBtn = document.getElementById('arBtn');

        // Device capability detection
        function detectDeviceCapabilities() {
            const cores = navigator.hardwareConcurrency || 4;
            const memory = navigator.deviceMemory || 4; // GB
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            let bufferSize = 10; // Conservative default
            let quality = 'medium';
            
            // Device-specific optimization
            if (memory >= 8 && cores >= 6) {
                bufferSize = 20;
                quality = 'high';
            } else if (memory >= 6 && cores >= 4) {
                bufferSize = 15;
                quality = 'medium-high';
            } else if (memory >= 4) {
                bufferSize = 12;
                quality = 'medium';
            }

            deviceCapabilities = {
                cores,
                memory,
                isMobile,
                bufferSize,
                quality,
                maxConcurrentLoads: Math.min(cores, 4),
                preloadFrames: Math.min(bufferSize / 4, 5)
            };

            updateDeviceInfo();
            return deviceCapabilities;
        }

        function updateDeviceInfo() {
            deviceInfo.innerHTML = `
                <div>Device: ${deviceCapabilities.isMobile ? 'Mobile' : 'Desktop'}</div>
                <div>CPU Cores: ${deviceCapabilities.cores}</div>
                <div>RAM: ${deviceCapabilities.memory}GB</div>
                <div>Quality: ${deviceCapabilities.quality}</div>
                <div>Buffer: ${deviceCapabilities.bufferSize} frames</div>
            `;
        }

        // Simplified Splat Sequence Player Class
        class SplatSequencePlayer {
            constructor() {
                this.folderPath = './data/splat';
                this.maxFrames = 400; // Known frame count
                this.currentFrame = 1;
                this.isPlaying = false;
                this.frameCache = new Map();
                this.bufferSize = deviceCapabilities.bufferSize;
                this.lastFrameTime = 0;
                this.targetFPS = 25;
                this.frameInterval = 1000 / this.targetFPS;
                this.actualFPS = 0;
                this.fpsCounter = 0;
                this.fpsStartTime = Date.now();
                this.isLoaded = false;
            }

            async loadFrame(frameNum) {
                const cacheKey = `frame_${frameNum}`;
                
                if (this.frameCache.has(cacheKey)) {
                    return this.frameCache.get(cacheKey);
                }

                const frameNumStr = frameNum.toString().padStart(6, '0');
                const url = `${this.folderPath}/frame_${frameNumStr}.splat`;
                
                try {
                    console.log(`üîÑ Loading frame ${frameNum}: ${url}`);
                    const splat = await SPLAT.Loader.LoadAsync(url, scene);
                    
                    // Cache management
                    if (this.frameCache.size >= this.bufferSize) {
                        this.cleanupOldFrames();
                    }
                    
                    this.frameCache.set(cacheKey, splat);
                    console.log(`‚úÖ Frame ${frameNum} loaded successfully`);
                    return splat;
                } catch (error) {
                    console.error(`‚ùå Failed to load frame ${frameNum}:`, error);
                    throw error;
                }
            }

            cleanupOldFrames() {
                const framesToKeep = this.bufferSize - 3;
                const cacheEntries = Array.from(this.frameCache.entries());
                
                for (let i = 0; i < cacheEntries.length - framesToKeep; i++) {
                    const [key, splat] = cacheEntries[i];
                    if (splat && splat !== currentSplat) {
                        scene.removeObject(splat);
                        splat.dispose?.();
                    }
                    this.frameCache.delete(key);
                }
            }

            async loadFirstFrame() {
                try {
                    updateStatus('üé¨ Loading first frame...', 'info');
                    const firstFrame = await this.loadFrame(1);
                    
                    if (firstFrame) {
                        this.replaceCurrentSplat(firstFrame);
                        this.currentFrame = 1;
                        this.isLoaded = true;
                        
                        // Preload a few more frames
                        this.preloadNextFrames();
                        
                        updateStatus('‚úÖ First frame loaded! Ready to play', 'success');
                        playBtn.disabled = false;
                        arBtn.disabled = false;
                        
                        return true;
                    }
                } catch (error) {
                    updateStatus(`‚ùå Failed to load first frame: ${error.message}`, 'error');
                    console.error('Load first frame error:', error);
                    return false;
                }
            }

            async preloadNextFrames() {
                const framesToPreload = [];
                const startFrame = this.currentFrame + 1;
                const endFrame = Math.min(startFrame + deviceCapabilities.preloadFrames, this.maxFrames);
                
                for (let i = startFrame; i <= endFrame; i++) {
                    const cacheKey = `frame_${i}`;
                    if (!this.frameCache.has(cacheKey)) {
                        framesToPreload.push(i);
                    }
                }
                
                // Load frames in parallel (limited by device capabilities)
                const loadPromises = framesToPreload.slice(0, deviceCapabilities.maxConcurrentLoads)
                    .map(frameNum => this.loadFrame(frameNum).catch(err => {
                        console.warn(`Failed to preload frame ${frameNum}:`, err);
                    }));
                
                await Promise.allSettled(loadPromises);
                console.log(`üîÑ Preloaded ${framesToPreload.length} frames`);
            }

            replaceCurrentSplat(newSplat) {
                // Remove current splat from scene
                if (currentSplat) {
                    scene.removeObject(currentSplat);
                }
                
                // Add new splat to scene (don't dispose, keep in cache)
                currentSplat = newSplat;
                this.updatePlaybackInfo();
            }

            async play() {
                if (!this.isLoaded) {
                    updateStatus('‚ùå Load sequence first!', 'error');
                    return;
                }

                if (this.isPlaying) return;
                
                this.isPlaying = true;
                this.lastFrameTime = Date.now();
                this.fpsStartTime = Date.now();
                this.fpsCounter = 0;
                
                updateStatus(`‚ñ∂Ô∏è Playing splat sequence (${this.maxFrames} frames at 25fps)`, 'success');
                playbackInfo.classList.add('visible');
                
                this.playLoop();
            }

            async playLoop() {
                if (!this.isPlaying) return;
                
                const now = Date.now();
                const deltaTime = now - this.lastFrameTime;
                
                if (deltaTime >= this.frameInterval) {
                    await this.nextFrame();
                    this.lastFrameTime = now;
                    
                    // FPS calculation
                    this.fpsCounter++;
                    if (this.fpsCounter % 10 === 0) {
                        const elapsed = (now - this.fpsStartTime) / 1000;
                        this.actualFPS = Math.round(this.fpsCounter / elapsed);
                    }
                }
                
                if (this.isPlaying) {
                    requestAnimationFrame(() => this.playLoop());
                }
            }

            async nextFrame() {
                this.currentFrame++;
                
                if (this.currentFrame > this.maxFrames) {
                    this.currentFrame = 1; // Loop back
                }
                
                try {
                    const frame = await this.loadFrame(this.currentFrame);
                    if (frame) {
                        this.replaceCurrentSplat(frame);
                        this.updatePlaybackInfo();
                        
                        // Trigger preloading occasionally
                        if (this.currentFrame % 5 === 0) {
                            this.preloadNextFrames();
                        }
                    }
                } catch (error) {
                    console.error(`Error loading frame ${this.currentFrame}:`, error);
                }
            }

            stop() {
                this.isPlaying = false;
                playbackInfo.classList.remove('visible');
                updateStatus('‚èπÔ∏è Playback stopped', 'info');
                playBtn.textContent = '‚ñ∂Ô∏è Play';
            }

            updatePlaybackInfo() {
                document.getElementById('currentFrame').textContent = this.currentFrame;
                document.getElementById('totalFrames').textContent = this.maxFrames;
                document.getElementById('currentFPS').textContent = this.actualFPS;
                document.getElementById('memoryUsage').textContent = Math.round(this.frameCache.size * 5);
                document.getElementById('bufferSize').textContent = this.frameCache.size;
            }

            dispose() {
                this.stop();
                this.frameCache.forEach(splat => {
                    if (splat) {
                        scene.removeObject(splat);
                        splat.dispose?.();
                    }
                });
                this.frameCache.clear();
                playbackInfo.classList.remove('visible');
                playBtn.disabled = true;
                arBtn.disabled = true;
            }
        }

        // Import gsplat.js
        async function loadGsplat() {
            try {
                updateStatus('üîÑ Loading gsplat.js library...', 'info');
                updateLoadingText('Loading gsplat.js library...');
                
                SPLAT = await import('https://cdn.jsdelivr.net/npm/gsplat@latest/dist/index.js');
                updateStatus('‚úÖ gsplat.js loaded successfully!', 'success');
                console.log('Available SPLAT classes:', Object.keys(SPLAT));
                
                return true;
            } catch (error) {
                updateStatus(`‚ùå Failed to load gsplat.js: ${error.message}`, 'error');
                console.error('gsplat.js import failed:', error);
                return false;
            }
        }

        // Initialize gsplat.js
        async function initializeGSplat() {
            try {
                updateLoadingText('Creating scene and camera...');
                scene = new SPLAT.Scene();
                camera = new SPLAT.Camera();
                camera.position = new SPLAT.Vector3(0, 1.6, 3);
                
                updateLoadingText('Creating WebGL renderer...');
                renderer = new SPLAT.WebGLRenderer(canvas);
                
                updateLoadingText('Setting up camera controls...');
                controls = new SPLAT.OrbitControls(camera, canvas);
                
                // Configure camera and renderer
                camera.data.setSize(window.innerWidth, window.innerHeight);
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                updateStatus('‚úÖ gsplat.js initialized successfully!', 'success');
                return true;
                
            } catch (error) {
                updateStatus(`‚ùå gsplat.js initialization failed: ${error.message}`, 'error');
                console.error('Initialization error:', error);
                return false;
            }
        }

        // Render loop
        function startRenderLoop() {
            function render() {
                try {
                    if (controls) {
                        controls.update();
                    }
                    
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                } catch (error) {
                    if (!render.errorLogged) {
                        console.error('Render error:', error);
                        render.errorLogged = true;
                    }
                }
                requestAnimationFrame(render);
            }
            render();
        }

        // UI utility functions
        function updateStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function updateLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
        }

        // Main functions for buttons
        async function loadSplatSequence() {
            if (currentSplatPlayer) {
                currentSplatPlayer.dispose();
            }
            
            loadSequenceBtn.disabled = true;
            loadSequenceBtn.textContent = 'üîÑ Loading...';
            
            currentSplatPlayer = new SplatSequencePlayer();
            const success = await currentSplatPlayer.loadFirstFrame();
            
            if (success) {
                loadSequenceBtn.textContent = '‚úÖ Loaded';
                loadSequenceBtn.disabled = false;
            } else {
                loadSequenceBtn.textContent = '‚ùå Failed';
                setTimeout(() => {
                    loadSequenceBtn.textContent = 'üé¨ Load Sequence';
                    loadSequenceBtn.disabled = false;
                }, 2000);
            }
        }

        function togglePlayback() {
            if (!currentSplatPlayer || !currentSplatPlayer.isLoaded) {
                updateStatus('‚ùå Load sequence first!', 'error');
                return;
            }
            
            if (currentSplatPlayer.isPlaying) {
                currentSplatPlayer.stop();
                playBtn.textContent = '‚ñ∂Ô∏è Play';
            } else {
                currentSplatPlayer.play();
                playBtn.textContent = '‚è∏Ô∏è Pause';
            }
        }

        function startAR() {
            if (!currentSplatPlayer || !currentSplatPlayer.isLoaded) {
                updateStatus('‚ùå Load sequence first!', 'error');
                return;
            }
            
            updateStatus('üöÄ AR mode - Tap anywhere to place sequence', 'info');
            gestureHint.classList.add('visible');
            
            // Simple AR simulation - click to place
            const arPlacement = (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // Move current splat to clicked position
                if (currentSplat) {
                    currentSplat.position.set(x * 3, 0, y * 3);
                    updateStatus('‚úÖ Sequence placed! Two fingers to scale/rotate', 'success');
                }
                
                canvas.removeEventListener('click', arPlacement);
            };
            
            canvas.addEventListener('click', arPlacement);
        }

        // Window resize handler
        function handleResize() {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            if (camera && renderer) {
                camera.data.setSize(width, height);
                renderer.setSize(width, height);
            }
        }

        // Main application entry point
        async function main() {
            try {
                updateLoadingText('Detecting device capabilities...');
                detectDeviceCapabilities();
                
                updateLoadingText('Loading gsplat.js library...');
                const gSplatLoaded = await loadGsplat();
                
                if (!gSplatLoaded) {
                    throw new Error('Failed to load gsplat.js library');
                }
                
                updateLoadingText('Initializing gsplat.js...');
                const gSplatReady = await initializeGSplat();
                
                if (!gSplatReady) {
                    throw new Error('Failed to initialize gsplat.js');
                }
                
                updateLoadingText('Starting render loop...');
                startRenderLoop();
                
                // Hide loading screen
                loading.classList.add('hidden');
                updateStatus('‚úÖ Ready! Click "Load Sequence" to start', 'success');
                
            } catch (error) {
                updateStatus(`‚ùå Application failed to start: ${error.message}`, 'error');
                console.error('Main initialization error:', error);
                loading.classList.add('hidden');
            }
        }

        // Event listeners
        window.addEventListener('resize', handleResize);

        // Global functions for buttons
        window.loadSplatSequence = loadSplatSequence;
        window.togglePlayback = togglePlayback;
        window.startAR = startAR;

        // Start the application
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', main);
        } else {
            main();
        }

        console.log('üé≠ AR Splat Demo - Single Sequence Test');
        console.log('üéØ Testing ./data/splat/ with 400 frames');

    </script>
</body>
</html>