<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ Single .splat File Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            overflow-x: hidden;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            backdrop-filter: blur(10px);
        }

        .status {
            position: fixed;
            top: 70px;
            left: 20px;
            right: 20px;
            z-index: 150;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .status.success {
            background: rgba(46, 204, 113, 0.8);
        }

        .status.error {
            background: rgba(231, 76, 60, 0.8);
        }

        .status.info {
            background: rgba(52, 152, 219, 0.8);
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #3498db;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            touch-action: none;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }

        .control-btn {
            padding: 15px 30px;
            background: rgba(52, 152, 219, 0.9);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(52, 152, 219, 1);
            transform: scale(1.05);
        }

        .control-btn:disabled {
            background: rgba(127, 140, 141, 0.5);
            cursor: not-allowed;
            transform: none;
        }

        .debug {
            position: fixed;
            top: 120px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ Single .splat File Test</h1>
        <p>Testing: https://github.com/lumigrade/LumiAR/raw/main/data/splat/frame_000001.splat</p>
    </div>

    <div class="status" id="status">Initializing...</div>

    <div class="debug" id="debug">
        Debug log:<br>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div id="loadingText">Initializing gsplat.js...</div>
    </div>

    <canvas id="canvas3d"></canvas>

    <div class="controls">
        <button class="control-btn" id="testBtn" onclick="testSingleSplat()" disabled>
            üî¨ Test Load frame_000001.splat
        </button>
    </div>

    <script type="module">
        // Global variables
        let SPLAT = null;
        let scene, camera, renderer, controls;

        // DOM elements
        const canvas = document.getElementById('canvas3d');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const debug = document.getElementById('debug');
        const testBtn = document.getElementById('testBtn');

        // Debug logging
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] ${message}`);
            debug.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            debug.scrollTop = debug.scrollHeight;
        }

        // Status updates
        function updateStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            log(`STATUS [${type}]: ${message}`);
        }

        function updateLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
            log(`LOADING: ${text}`);
        }

        // Import gsplat.js with console.assert polyfill
        async function loadGsplat() {
            try {
                // Add console.assert polyfill (gsplat.js needs this)
                if (!console.assert) {
                    console.assert = function(condition, message) {
                        if (!condition) {
                            console.error('Assertion failed:', message || 'Assertion failed');
                            throw new Error(message || 'Assertion failed');
                        }
                    };
                    log('‚úÖ console.assert polyfill added');
                }

                updateLoadingText('Loading gsplat.js library...');
                log('üì¶ Importing gsplat.js from CDN...');
                
                SPLAT = await import('https://cdn.jsdelivr.net/npm/gsplat@latest/dist/index.js');
                
                log(`‚úÖ gsplat.js imported successfully`);
                log(`üìã Available classes: ${Object.keys(SPLAT).join(', ')}`);
                
                return true;
            } catch (error) {
                log(`‚ùå Failed to import gsplat.js: ${error.message}`);
                log(`üìã Error stack: ${error.stack}`);
                return false;
            }
        }

        // Initialize gsplat.js components
        async function initializeGSplat() {
            try {
                updateLoadingText('Creating scene...');
                log('üèóÔ∏è Creating SPLAT.Scene()...');
                scene = new SPLAT.Scene();
                log('‚úÖ Scene created');
                
                updateLoadingText('Creating camera...');
                log('üìπ Creating SPLAT.Camera()...');
                camera = new SPLAT.Camera();
                camera.position = new SPLAT.Vector3(0, 1.6, 3);
                log('‚úÖ Camera created and positioned');
                
                updateLoadingText('Creating renderer...');
                log('üñºÔ∏è Creating SPLAT.WebGLRenderer()...');
                renderer = new SPLAT.WebGLRenderer(canvas);
                log('‚úÖ Renderer created');
                
                updateLoadingText('Setting up controls...');
                log('üéÆ Creating SPLAT.OrbitControls()...');
                controls = new SPLAT.OrbitControls(camera, canvas);
                log('‚úÖ Controls created');
                
                updateLoadingText('Configuring viewport...');
                log('üìê Configuring camera and renderer sizes...');
                camera.data.setSize(window.innerWidth, window.innerHeight);
                renderer.setSize(window.innerWidth, window.innerHeight);
                log('‚úÖ Viewport configured');
                
                return true;
                
            } catch (error) {
                log(`‚ùå Initialization failed: ${error.message}`);
                log(`üìã Error stack: ${error.stack}`);
                return false;
            }
        }

        // Start render loop
        function startRenderLoop() {
            log('üîÑ Starting render loop...');
            
            function render() {
                try {
                    if (controls) {
                        controls.update();
                    }
                    
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                } catch (error) {
                    if (!render.errorLogged) {
                        log(`‚ùå Render error: ${error.message}`);
                        render.errorLogged = true;
                    }
                }
                requestAnimationFrame(render);
            }
            
            render();
            log('‚úÖ Render loop started');
        }

        // Test loading single .splat file with format validation
        async function testSingleSplat() {
            if (!SPLAT) {
                updateStatus('‚ùå gsplat.js not loaded!', 'error');
                return;
            }

            const url = 'https://github.com/lumigrade/LumiAR/raw/main/data/splat/frame_000001.splat';
            
            testBtn.disabled = true;
            testBtn.textContent = 'üîÑ Loading...';
            
            try {
                log('üß™ TESTING SINGLE .SPLAT FILE LOAD');
                log(`üìÅ URL: ${url}`);
                
                // Step 1: Fetch the raw file data
                log('üîç Fetching raw file data...');
                const response = await fetch(url);
                log(`üìä Response: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    throw new Error(`File not found: ${response.status} ${response.statusText}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                const fileSizeBytes = arrayBuffer.byteLength;
                const fileSizeMB = (fileSizeBytes / 1024 / 1024).toFixed(2);
                log(`üìè File size: ${fileSizeBytes} bytes (${fileSizeMB} MB)`);
                
                // Step 2: Validate .splat file format
                const expectedGaussians = fileSizeBytes / 32;
                log(`üßÆ Expected gaussians: ${expectedGaussians.toLocaleString()} (at 32 bytes each)`);
                
                if (fileSizeBytes % 32 !== 0) {
                    log(`‚ö†Ô∏è WARNING: File size ${fileSizeBytes} not divisible by 32!`);
                    log(`üîß Remainder: ${fileSizeBytes % 32} bytes`);
                }
                
                // Step 3: Try direct SplatData.Deserialize (bypass Loader)
                log('üî¨ Testing direct SplatData.Deserialize()...');
                try {
                    const buffer = new Uint8Array(arrayBuffer);
                    log(`üì¶ Created Uint8Array buffer: ${buffer.length} bytes`);
                    
                    // This is what Loader.LoadFromArrayBuffer does internally
                    const data = SPLAT.SplatData.Deserialize(buffer);
                    log(`‚úÖ SplatData.Deserialize() succeeded!`);
                    log(`üî¢ Vertex count: ${data.vertexCount.toLocaleString()}`);
                    
                    // Step 4: Create Splat object
                    log('üèóÔ∏è Creating Splat object...');
                    scene.reset();
                    const splat = new SPLAT.Splat(data);
                    scene.addObject(splat);
                    log(`‚úÖ Splat object created and added to scene`);
                    
                    // Step 5: Position camera
                    if (controls) {
                        const bounds = splat.bounds;
                        const center = bounds.center();
                        const size = bounds.size();
                        
                        log(`üìê Bounds center: [${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}]`);
                        log(`üìè Bounds size: [${size.x.toFixed(2)}, ${size.y.toFixed(2)}, ${size.z.toFixed(2)}]`);
                        
                        // Calculate distance using Vector3 magnitude
                        const distance = Math.sqrt(size.x * size.x + size.y * size.y + size.z * size.z) * 2;
                        log(`üìè Calculated distance: ${distance.toFixed(2)}`);
                        
                        camera.position.set(
                            center.x + distance * 0.7,
                            center.y + distance * 0.5, 
                            center.z + distance * 0.7
                        );
                        controls.setCameraTarget(center);
                        log('üìπ Camera positioned to view splat');
                    }
                    
                    updateStatus(`‚úÖ SUCCESS! Direct load: ${data.vertexCount.toLocaleString()} gaussians`, 'success');
                    testBtn.textContent = '‚úÖ Direct Load Success!';
                    
                } catch (deserializeError) {
                    log(`‚ùå SplatData.Deserialize() failed: ${deserializeError.message}`);
                    log(`üìã Deserialize error stack: ${deserializeError.stack}`);
                    
                    // Step 4: Try as PLY file instead
                    log('üîÑ Trying PLYLoader as fallback...');
                    try {
                        scene.reset();
                        
                        // Check if it might be a PLY file
                        const header = new TextDecoder().decode(buffer.slice(0, 100));
                        log(`üìù File header (first 100 chars): "${header}"`);
                        
                        if (header.startsWith('ply\n')) {
                            log('üéØ File appears to be PLY format!');
                            const splat = await SPLAT.PLYLoader.LoadAsync(url, scene);
                            log(`‚úÖ PLYLoader succeeded: ${splat.data.vertexCount.toLocaleString()} gaussians`);
                            updateStatus(`‚úÖ SUCCESS! PLY load: ${splat.data.vertexCount.toLocaleString()} gaussians`, 'success');
                            testBtn.textContent = '‚úÖ PLY Load Success!';
                        } else {
                            log('‚ùå File is not PLY format either');
                            throw new Error(`File format not recognized. Header: "${header.slice(0, 20)}"`);
                        }
                        
                    } catch (plyError) {
                        log(`‚ùå PLYLoader also failed: ${plyError.message}`);
                        throw deserializeError; // Throw the original error
                    }
                }
                
            } catch (error) {
                log(`‚ùå COMPLETE FAILURE: ${error.message}`);
                log(`üìã Error stack: ${error.stack}`);
                log(`üîç Error name: ${error.name}`);
                
                // Additional debugging info
                log('üî¨ DEBUGGING INFO:');
                log(`- Is SPLAT defined? ${typeof SPLAT}`);
                log(`- SPLAT.SplatData available? ${typeof SPLAT.SplatData}`);
                log(`- SPLAT.SplatData.Deserialize available? ${typeof SPLAT.SplatData?.Deserialize}`);
                
                updateStatus(`‚ùå Failed: ${error.message}`, 'error');
                testBtn.textContent = '‚ùå Failed - Try Again';
                
                setTimeout(() => {
                    testBtn.textContent = 'üî¨ Test Load frame_000001.splat';
                    testBtn.disabled = false;
                }, 3000);
            }
        }

        // Window resize handler
        function handleResize() {
            if (camera && renderer) {
                camera.data.setSize(window.innerWidth, window.innerHeight);
                renderer.setSize(window.innerWidth, window.innerHeight);
                log('üìê Window resized, viewport updated');
            }
        }

        // Main initialization
        async function main() {
            try {
                log('üöÄ Starting application...');
                
                const gSplatLoaded = await loadGsplat();
                if (!gSplatLoaded) {
                    throw new Error('Failed to load gsplat.js');
                }
                
                const gSplatReady = await initializeGSplat();
                if (!gSplatReady) {
                    throw new Error('Failed to initialize gsplat.js');
                }
                
                startRenderLoop();
                
                // Hide loading, enable test button
                loading.classList.add('hidden');
                testBtn.disabled = false;
                
                updateStatus('‚úÖ Ready to test! Click button to load .splat file', 'success');
                log('üéØ Application ready - click test button');
                
            } catch (error) {
                log(`‚ùå Application startup failed: ${error.message}`);
                updateStatus(`‚ùå Startup failed: ${error.message}`, 'error');
                loading.classList.add('hidden');
            }
        }

        // Event listeners
        window.addEventListener('resize', handleResize);
        
        // Global function for button
        window.testSingleSplat = testSingleSplat;

        // Start the application
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', main);
        } else {
            main();
        }

    </script>
</body>
</html>