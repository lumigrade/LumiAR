<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé≠ AR Splat 400-Frame Sequence Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            overflow-x: hidden;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            backdrop-filter: blur(10px);
        }

        .status {
            position: fixed;
            top: 70px;
            left: 20px;
            right: 20px;
            z-index: 150;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .status.success { background: rgba(46, 204, 113, 0.8); }
        .status.error { background: rgba(231, 76, 60, 0.8); }
        .status.info { background: rgba(52, 152, 219, 0.8); }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #3498db;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            touch-action: none;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-btn {
            padding: 12px 20px;
            background: rgba(52, 152, 219, 0.9);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .control-btn:hover {
            background: rgba(52, 152, 219, 1);
            transform: scale(1.05);
        }

        .control-btn:disabled {
            background: rgba(127, 140, 141, 0.5);
            cursor: not-allowed;
            transform: none;
        }

        .ar-button {
            background: rgba(46, 204, 113, 0.9);
        }

        .ar-button:hover {
            background: rgba(46, 204, 113, 1);
        }

        .playback-info {
            position: fixed;
            top: 120px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
            display: none;
        }

        .playback-info.visible {
            display: block;
        }

        .debug {
            position: fixed;
            top: 120px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 10px;
            font-family: monospace;
            z-index: 100;
            max-height: 300px;
            max-width: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé≠ AR Splat 400-Frame Sequence Player</h1>
        <p>Gaussian Splat sequence animation with AR placement</p>
    </div>

    <div class="status" id="status">Initializing...</div>

    <div class="playback-info" id="playbackInfo">
        <div>Frame: <span id="currentFrame">0</span>/<span id="totalFrames">400</span></div>
        <div>FPS: <span id="currentFPS">0</span></div>
        <div>Gaussians: <span id="gaussianCount">0</span></div>
        <div>Status: <span id="playStatus">Stopped</span></div>
    </div>

    <div class="debug" id="debug">
        Debug log:<br>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div id="loadingText">Initializing gsplat.js...</div>
    </div>

    <canvas id="canvas3d"></canvas>

    <div class="controls">
        <button class="control-btn" id="loadBtn" onclick="loadFirstFrame()">üé¨ Load Frame 1</button>
        <button class="control-btn" id="playBtn" onclick="togglePlayback()" disabled>‚ñ∂Ô∏è Play Sequence</button>
        <button class="ar-button control-btn" id="arBtn" onclick="startAR()" disabled>üöÄ AR Mode</button>
    </div>

    <script type="module">
        // Global variables - keeping it simple like the working test
        let SPLAT = null;
        let scene, camera, renderer, controls;
        let sequencePlayer = null;

        // DOM elements
        const canvas = document.getElementById('canvas3d');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const debug = document.getElementById('debug');
        const playbackInfo = document.getElementById('playbackInfo');
        const loadBtn = document.getElementById('loadBtn');
        const playBtn = document.getElementById('playBtn');
        const arBtn = document.getElementById('arBtn');

        // Debug logging - exactly like the working test
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] ${message}`);
            debug.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            debug.scrollTop = debug.scrollHeight;
        }

        // Status updates
        function updateStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            log(`STATUS [${type}]: ${message}`);
        }

        function updateLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
            log(`LOADING: ${text}`);
        }

        // Simple Sequence Player
        class SimpleSequencePlayer {
            constructor() {
                this.folderPath = './data/splat';
                this.maxFrames = 400;
                this.currentFrame = 1;
                this.isPlaying = false;
                this.currentSplat = null;
                this.targetFPS = 25;
                this.frameInterval = 1000 / this.targetFPS;
                this.lastFrameTime = 0;
                this.actualFPS = 0;
                this.fpsCounter = 0;
                this.fpsStartTime = Date.now();
                this.isLoaded = false;
                
                log('üé¨ Simple sequence player created');
            }

            async loadSingleFrame(frameNum) {
                const frameNumStr = frameNum.toString().padStart(6, '0');
                const url = `${this.folderPath}/frame_${frameNumStr}.splat`;
                
                try {
                    // Use the exact same method that worked for single frame test
                    log(`üì• Loading frame ${frameNum}: ${url}`);
                    
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Frame ${frameNum} not found: ${response.status}`);
                    }
                    
                    const arrayBuffer = await response.arrayBuffer();
                    const fileSizeBytes = arrayBuffer.byteLength;
                    log(`üìä Frame ${frameNum} size: ${fileSizeBytes} bytes`);
                    
                    // Direct SplatData.Deserialize - the proven working method
                    const buffer = new Uint8Array(arrayBuffer);
                    const data = SPLAT.SplatData.Deserialize(buffer);
                    const splat = new SPLAT.Splat(data);
                    
                    log(`‚úÖ Frame ${frameNum} loaded: ${data.vertexCount} gaussians`);
                    return splat;
                    
                } catch (error) {
                    log(`‚ùå Failed to load frame ${frameNum}: ${error.message}`);
                    throw error;
                }
            }

            async loadFirstFrame() {
                try {
                    updateStatus('Loading first frame...', 'info');
                    
                    // Clear scene first
                    scene.reset();
                    this.currentSplat = null;
                    
                    // Load frame 1
                    const firstFrame = await this.loadSingleFrame(1);
                    
                    // Add to scene
                    scene.addObject(firstFrame);
                    this.currentSplat = firstFrame;
                    this.currentFrame = 1;
                    this.isLoaded = true;
                    
                    // Position camera - same as working test
                    this.positionCamera(firstFrame);
                    
                    // Update UI
                    this.updatePlaybackInfo();
                    
                    updateStatus('‚úÖ First frame loaded! Ready for sequence', 'success');
                    log('‚úÖ First frame ready for playback');
                    
                    return true;
                } catch (error) {
                    updateStatus(`‚ùå Failed to load first frame: ${error.message}`, 'error');
                    log(`‚ùå First frame load failed: ${error.message}`);
                    return false;
                }
            }

            positionCamera(splat) {
                if (!controls) return;
                
                try {
                    const bounds = splat.bounds;
                    const center = bounds.center();
                    const size = bounds.size();
                    const distance = Math.sqrt(size.x * size.x + size.y * size.y + size.z * size.z) * 2;
                    
                    camera.position = new SPLAT.Vector3(
                        center.x + distance * 0.7,
                        center.y + distance * 0.5,
                        center.z + distance * 0.7
                    );
                    controls.setCameraTarget(center);
                    
                    log(`üìπ Camera positioned at distance ${distance.toFixed(2)}`);
                } catch (error) {
                    log(`‚ö†Ô∏è Camera positioning failed: ${error.message}`);
                }
            }

            replaceCurrentSplat(newSplat) {
                // Remove current splat from scene
                if (this.currentSplat) {
                    scene.removeObject(this.currentSplat);
                }
                
                // Add new splat to scene
                scene.addObject(newSplat);
                this.currentSplat = newSplat;
                
                this.updatePlaybackInfo();
            }

            async startSequence() {
                if (!this.isLoaded) {
                    updateStatus('‚ùå Load first frame first!', 'error');
                    return;
                }

                if (this.isPlaying) return;
                
                this.isPlaying = true;
                this.lastFrameTime = Date.now();
                this.fpsStartTime = Date.now();
                this.fpsCounter = 0;
                
                updateStatus('‚ñ∂Ô∏è Playing 400-frame sequence at 25fps', 'success');
                log(`‚ñ∂Ô∏è Starting sequence playback from frame ${this.currentFrame}`);
                playbackInfo.classList.add('visible');
                
                this.animationLoop();
            }

            async animationLoop() {
                if (!this.isPlaying) return;
                
                const now = Date.now();
                const deltaTime = now - this.lastFrameTime;
                
                if (deltaTime >= this.frameInterval) {
                    await this.nextFrame();
                    this.lastFrameTime = now;
                    
                    // Calculate FPS
                    this.fpsCounter++;
                    if (this.fpsCounter % 10 === 0) {
                        const elapsed = (now - this.fpsStartTime) / 1000;
                        this.actualFPS = Math.round(this.fpsCounter / elapsed);
                    }
                }
                
                if (this.isPlaying) {
                    requestAnimationFrame(() => this.animationLoop());
                }
            }

            async nextFrame() {
                this.currentFrame++;
                if (this.currentFrame > this.maxFrames) {
                    this.currentFrame = 1; // Loop back
                    log('üîÑ Sequence looped back to frame 1');
                }
                
                try {
                    const frame = await this.loadSingleFrame(this.currentFrame);
                    this.replaceCurrentSplat(frame);
                    
                    if (this.currentFrame % 50 === 0) {
                        log(`üìä Sequence progress: frame ${this.currentFrame}/${this.maxFrames}`);
                    }
                    
                } catch (error) {
                    log(`‚ö†Ô∏è Frame ${this.currentFrame} failed, continuing: ${error.message}`);
                    // Continue playing even if one frame fails
                }
            }

            stop() {
                this.isPlaying = false;
                playbackInfo.classList.remove('visible');
                updateStatus('‚èπÔ∏è Sequence stopped', 'info');
                log(`‚èπÔ∏è Stopped at frame ${this.currentFrame}`);
            }

            updatePlaybackInfo() {
                if (!this.currentSplat) return;
                
                document.getElementById('currentFrame').textContent = this.currentFrame;
                document.getElementById('currentFPS').textContent = this.actualFPS;
                document.getElementById('gaussianCount').textContent = this.currentSplat.data.vertexCount.toLocaleString();
                document.getElementById('playStatus').textContent = this.isPlaying ? 'Playing' : 'Stopped';
            }

            placeInAR(position) {
                if (this.currentSplat) {
                    this.currentSplat.position = new SPLAT.Vector3(position.x, position.y, position.z);
                    updateStatus('üöÄ AR Mode: Sequence placed!', 'success');
                    log(`üöÄ AR placement: [${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}]`);
                }
            }
        }

        // Import gsplat.js - using the exact working method
        async function loadGsplat() {
            try {
                // Add console.assert polyfill (gsplat.js needs this)
                if (!console.assert) {
                    console.assert = function(condition, message) {
                        if (!condition) {
                            console.error('Assertion failed:', message || 'Assertion failed');
                            throw new Error(message || 'Assertion failed');
                        }
                    };
                    log('‚úÖ console.assert polyfill added');
                }

                updateLoadingText('Loading gsplat.js library...');
                log('üì¶ Importing gsplat.js from CDN...');
                
                SPLAT = await import('https://cdn.jsdelivr.net/npm/gsplat@latest/dist/index.js');
                
                log(`‚úÖ gsplat.js imported successfully`);
                log(`üìã Available classes: ${Object.keys(SPLAT).join(', ')}`);
                
                return true;
            } catch (error) {
                log(`‚ùå Failed to import gsplat.js: ${error.message}`);
                log(`üìã Error stack: ${error.stack}`);
                return false;
            }
        }

        // Initialize gsplat.js - using the exact working method
        async function initializeGSplat() {
            try {
                updateLoadingText('Creating scene...');
                log('üèóÔ∏è Creating SPLAT.Scene()...');
                scene = new SPLAT.Scene();
                log('‚úÖ Scene created');
                
                updateLoadingText('Creating camera...');
                log('üìπ Creating SPLAT.Camera()...');
                camera = new SPLAT.Camera();
                camera.position = new SPLAT.Vector3(0, 1.6, 3);
                log('‚úÖ Camera created and positioned');
                
                updateLoadingText('Creating renderer...');
                log('üñºÔ∏è Creating SPLAT.WebGLRenderer()...');
                renderer = new SPLAT.WebGLRenderer(canvas);
                log('‚úÖ Renderer created');
                
                updateLoadingText('Setting up controls...');
                log('üéÆ Creating SPLAT.OrbitControls()...');
                controls = new SPLAT.OrbitControls(camera, canvas);
                log('‚úÖ Controls created');
                
                updateLoadingText('Configuring viewport...');
                log('üìê Configuring camera and renderer sizes...');
                camera.data.setSize(window.innerWidth, window.innerHeight);
                renderer.setSize(window.innerWidth, window.innerHeight);
                log('‚úÖ Viewport configured');
                
                return true;
                
            } catch (error) {
                log(`‚ùå Initialization failed: ${error.message}`);
                log(`üìã Error stack: ${error.stack}`);
                return false;
            }
        }

        // Start render loop - using the exact working method
        function startRenderLoop() {
            log('üîÑ Starting render loop...');
            
            function render() {
                try {
                    if (controls) {
                        controls.update();
                    }
                    
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                } catch (error) {
                    if (!render.errorLogged) {
                        log(`‚ùå Render error: ${error.message}`);
                        render.errorLogged = true;
                    }
                }
                requestAnimationFrame(render);
            }
            
            render();
            log('‚úÖ Render loop started');
        }

        // Button functions
        async function loadFirstFrame() {
            if (!SPLAT) {
                updateStatus('‚ùå gsplat.js not loaded!', 'error');
                return;
            }

            loadBtn.disabled = true;
            loadBtn.textContent = 'üîÑ Loading...';
            
            try {
                // Create sequence player
                sequencePlayer = new SimpleSequencePlayer();
                
                // Load first frame
                const success = await sequencePlayer.loadFirstFrame();
                
                if (success) {
                    loadBtn.textContent = '‚úÖ Frame 1 Loaded';
                    playBtn.disabled = false;
                    arBtn.disabled = false;
                } else {
                    loadBtn.textContent = '‚ùå Failed';
                    setTimeout(() => {
                        loadBtn.textContent = 'üé¨ Load Frame 1';
                        loadBtn.disabled = false;
                    }, 3000);
                }
                
            } catch (error) {
                log(`‚ùå Load first frame error: ${error.message}`);
                loadBtn.textContent = '‚ùå Failed';
                setTimeout(() => {
                    loadBtn.textContent = 'üé¨ Load Frame 1';
                    loadBtn.disabled = false;
                }, 3000);
            }
        }

        function togglePlayback() {
            if (!sequencePlayer || !sequencePlayer.isLoaded) {
                updateStatus('‚ùå Load first frame first!', 'error');
                return;
            }
            
            if (sequencePlayer.isPlaying) {
                sequencePlayer.stop();
                playBtn.textContent = '‚ñ∂Ô∏è Play Sequence';
            } else {
                sequencePlayer.startSequence();
                playBtn.textContent = '‚è∏Ô∏è Stop';
            }
        }

        function startAR() {
            if (!sequencePlayer || !sequencePlayer.isLoaded) {
                updateStatus('‚ùå Load first frame first!', 'error');
                return;
            }
            
            updateStatus('üéØ AR Mode - Tap anywhere to place sequence', 'info');
            
            // Simple click-to-place AR
            const arPlacement = (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                const position = {
                    x: x * 5,
                    y: 0,
                    z: y * 5
                };
                
                sequencePlayer.placeInAR(position);
                canvas.removeEventListener('click', arPlacement);
            };
            
            canvas.addEventListener('click', arPlacement);
        }

        // Window resize handler
        function handleResize() {
            if (camera && renderer) {
                camera.data.setSize(window.innerWidth, window.innerHeight);
                renderer.setSize(window.innerWidth, window.innerHeight);
                log('üìê Window resized, viewport updated');
            }
        }

        // Main initialization - using the exact working method
        async function main() {
            try {
                log('üöÄ Starting application...');
                
                const gSplatLoaded = await loadGsplat();
                if (!gSplatLoaded) {
                    throw new Error('Failed to load gsplat.js');
                }
                
                const gSplatReady = await initializeGSplat();
                if (!gSplatReady) {
                    throw new Error('Failed to initialize gsplat.js');
                }
                
                startRenderLoop();
                
                // Hide loading, enable test button
                loading.classList.add('hidden');
                updateStatus('‚úÖ Ready! Click "Load Frame 1" to start sequence', 'success');
                log('üéØ Application ready - sequence player initialized');
                
            } catch (error) {
                log(`‚ùå Application startup failed: ${error.message}`);
                updateStatus(`‚ùå Startup failed: ${error.message}`, 'error');
                loading.classList.add('hidden');
            }
        }

        // Event listeners
        window.addEventListener('resize', handleResize);
        
        // Global functions for buttons
        window.loadFirstFrame = loadFirstFrame;
        window.togglePlayback = togglePlayback;
        window.startAR = startAR;

        // Start the application - same as working test
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', main);
        } else {
            main();
        }

    </script>
</body>
</html>