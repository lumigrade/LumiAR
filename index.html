<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé≠ AR Splat Sequence Demo - Proper .splat Loading</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            overflow-x: hidden;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 18px;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 12px;
            opacity: 0.7;
        }

        .status {
            position: fixed;
            top: 80px;
            left: 20px;
            right: 20px;
            z-index: 150;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .status.success {
            background: rgba(46, 204, 113, 0.8);
            border: 1px solid rgba(46, 204, 113, 0.3);
        }

        .status.error {
            background: rgba(231, 76, 60, 0.8);
            border: 1px solid rgba(231, 76, 60, 0.3);
        }

        .status.info {
            background: rgba(52, 152, 219, 0.8);
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #3498db;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            touch-action: none;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .main-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-btn {
            padding: 12px 20px;
            background: rgba(52, 152, 219, 0.9);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .control-btn:hover {
            background: rgba(52, 152, 219, 1);
            transform: scale(1.05);
        }

        .control-btn:disabled {
            background: rgba(127, 140, 141, 0.5);
            cursor: not-allowed;
            transform: none;
        }

        .ar-button {
            background: rgba(46, 204, 113, 0.9);
        }

        .ar-button:hover {
            background: rgba(46, 204, 113, 1);
        }

        .debug-info {
            position: fixed;
            top: 130px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 5px;
            font-size: 10px;
            font-family: monospace;
            z-index: 100;
            max-width: 200px;
        }

        .playback-info {
            position: fixed;
            top: 130px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 5px;
            font-size: 10px;
            font-family: monospace;
            z-index: 100;
            display: none;
        }

        .playback-info.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé≠ AR Splat Sequence Demo - Proper .splat Loading</h1>
        <p>Testing ./data/splat/ sequence using correct gsplat.js Loader</p>
    </div>

    <div class="status" id="status">Initializing AR Splat System...</div>
    
    <div class="debug-info" id="debugInfo">
        Debug info will appear here...
    </div>

    <div class="playback-info" id="playbackInfo">
        <div>Frame: <span id="currentFrame">0</span>/<span id="totalFrames">400</span></div>
        <div>FPS: <span id="currentFPS">0</span></div>
        <div>Gaussians: <span id="gaussianCount">0</span></div>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div id="loadingText">Initializing gsplat.js...</div>
    </div>

    <canvas id="canvas3d"></canvas>

    <div class="controls">
        <div class="main-controls">
            <button class="control-btn" id="loadFirstBtn" onclick="loadFirstFrame()">üé¨ Load Frame 1</button>
            <button class="control-btn" id="playBtn" onclick="toggleSequence()" disabled>‚ñ∂Ô∏è Play Sequence</button>
            <button class="ar-button control-btn" id="arBtn" onclick="startAR()" disabled>üöÄ AR Mode</button>
        </div>
    </div>

    <script type="module">
        // Global variables
        let SPLAT = null;
        let scene, camera, renderer, controls;
        let currentSplat = null;
        let sequencePlayer = null;

        // DOM elements
        const canvas = document.getElementById('canvas3d');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const debugInfo = document.getElementById('debugInfo');
        const playbackInfo = document.getElementById('playbackInfo');
        const loadFirstBtn = document.getElementById('loadFirstBtn');
        const playBtn = document.getElementById('playBtn');
        const arBtn = document.getElementById('arBtn');

        // Debug logging
        function debugLog(message) {
            console.log('[DEBUG]', message);
            debugInfo.innerHTML += `${new Date().toLocaleTimeString()}: ${message}<br>`;
            debugInfo.scrollTop = debugInfo.scrollHeight;
        }

        // Sequence Player Class - using proper gsplat.js Loader
        class SplatSequencePlayer {
            constructor() {
                this.folderPath = './data/splat';
                this.maxFrames = 400;
                this.currentFrame = 1;
                this.isPlaying = false;
                this.targetFPS = 25;
                this.frameInterval = 1000 / this.targetFPS;
                this.lastFrameTime = 0;
                this.actualFPS = 0;
                this.fpsCounter = 0;
                this.fpsStartTime = Date.now();
            }

            async loadSingleFrame(frameNum) {
                const frameNumStr = frameNum.toString().padStart(6, '0');
                const url = `${this.folderPath}/frame_${frameNumStr}.splat`;
                
                try {
                    debugLog(`Loading frame ${frameNum}: ${url}`);
                    
                    // Clear the scene first (important!)
                    scene.reset();
                    currentSplat = null;
                    
                    // Use proper gsplat.js Loader with progress callback
                    const splat = await SPLAT.Loader.LoadAsync(url, scene, (progress) => {
                        if (progress < 1.0) {
                            const percent = (progress * 100).toFixed(0);
                            updateStatus(`Loading frame ${frameNum}: ${percent}%`, 'info');
                        }
                    });
                    
                    currentSplat = splat;
                    debugLog(`‚úÖ Frame ${frameNum} loaded: ${splat.data.vertexCount} gaussians`);
                    
                    // Update UI
                    this.updatePlaybackInfo(frameNum, splat.data.vertexCount);
                    
                    return splat;
                } catch (error) {
                    debugLog(`‚ùå Failed to load frame ${frameNum}: ${error.message}`);
                    throw error;
                }
            }

            async playSequence() {
                if (this.isPlaying) return;
                
                this.isPlaying = true;
                this.lastFrameTime = Date.now();
                this.fpsStartTime = Date.now();
                this.fpsCounter = 0;
                
                debugLog('‚ñ∂Ô∏è Starting sequence playback');
                updateStatus('‚ñ∂Ô∏è Playing sequence at 25fps', 'success');
                playbackInfo.classList.add('visible');
                
                this.animationLoop();
            }

            async animationLoop() {
                if (!this.isPlaying) return;
                
                const now = Date.now();
                const deltaTime = now - this.lastFrameTime;
                
                if (deltaTime >= this.frameInterval) {
                    await this.nextFrame();
                    this.lastFrameTime = now;
                    
                    // Calculate FPS
                    this.fpsCounter++;
                    if (this.fpsCounter % 10 === 0) {
                        const elapsed = (now - this.fpsStartTime) / 1000;
                        this.actualFPS = Math.round(this.fpsCounter / elapsed);
                    }
                }
                
                if (this.isPlaying) {
                    requestAnimationFrame(() => this.animationLoop());
                }
            }

            async nextFrame() {
                this.currentFrame++;
                if (this.currentFrame > this.maxFrames) {
                    this.currentFrame = 1; // Loop
                }
                
                try {
                    await this.loadSingleFrame(this.currentFrame);
                } catch (error) {
                    debugLog(`Error in nextFrame: ${error.message}`);
                    // Continue playing even if one frame fails
                }
            }

            stop() {
                this.isPlaying = false;
                debugLog('‚èπÔ∏è Sequence stopped');
                updateStatus('‚èπÔ∏è Sequence stopped', 'info');
                playBtn.textContent = '‚ñ∂Ô∏è Play Sequence';
            }

            updatePlaybackInfo(frameNum, gaussianCount) {
                document.getElementById('currentFrame').textContent = frameNum;
                document.getElementById('currentFPS').textContent = this.actualFPS;
                document.getElementById('gaussianCount').textContent = gaussianCount.toLocaleString();
            }
        }

        // Import gsplat.js
        async function loadGsplat() {
            try {
                updateStatus('üîÑ Loading gsplat.js library...', 'info');
                updateLoadingText('Loading gsplat.js library...');
                
                SPLAT = await import('https://cdn.jsdelivr.net/npm/gsplat@latest/dist/index.js');
                debugLog('‚úÖ gsplat.js loaded successfully');
                debugLog(`Available classes: ${Object.keys(SPLAT).slice(0, 10).join(', ')}...`);
                
                return true;
            } catch (error) {
                updateStatus(`‚ùå Failed to load gsplat.js: ${error.message}`, 'error');
                debugLog(`Failed to load gsplat.js: ${error.message}`);
                return false;
            }
        }

        // Initialize gsplat.js
        async function initializeGSplat() {
            try {
                updateLoadingText('Creating scene and camera...');
                scene = new SPLAT.Scene();
                camera = new SPLAT.Camera();
                camera.position = new SPLAT.Vector3(0, 1.6, 3);
                debugLog('Scene and camera created');
                
                updateLoadingText('Creating WebGL renderer...');
                renderer = new SPLAT.WebGLRenderer(canvas);
                debugLog('Renderer created');
                
                updateLoadingText('Setting up camera controls...');
                controls = new SPLAT.OrbitControls(camera, canvas);
                debugLog('Controls created');
                
                // Configure camera and renderer
                camera.data.setSize(window.innerWidth, window.innerHeight);
                renderer.setSize(window.innerWidth, window.innerHeight);
                debugLog('Camera and renderer configured');
                
                return true;
                
            } catch (error) {
                updateStatus(`‚ùå gsplat.js initialization failed: ${error.message}`, 'error');
                debugLog(`Initialization failed: ${error.message}`);
                return false;
            }
        }

        // Render loop
        function startRenderLoop() {
            debugLog('Starting render loop');
            
            function render() {
                try {
                    if (controls) {
                        controls.update();
                    }
                    
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                } catch (error) {
                    if (!render.errorLogged) {
                        debugLog(`Render error: ${error.message}`);
                        render.errorLogged = true;
                    }
                }
                requestAnimationFrame(render);
            }
            render();
        }

        // UI utility functions
        function updateStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            debugLog(`[${type.toUpperCase()}] ${message}`);
        }

        function updateLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
        }

        // Button functions
        async function loadFirstFrame() {
            if (!SPLAT) {
                updateStatus('‚ùå gsplat.js not loaded yet!', 'error');
                return;
            }
            
            loadFirstBtn.disabled = true;
            loadFirstBtn.textContent = 'üîÑ Loading...';
            
            try {
                // Create sequence player
                sequencePlayer = new SplatSequencePlayer();
                
                // Load first frame
                await sequencePlayer.loadSingleFrame(1);
                
                updateStatus('‚úÖ Frame 1 loaded successfully!', 'success');
                loadFirstBtn.textContent = '‚úÖ Frame 1 Loaded';
                playBtn.disabled = false;
                arBtn.disabled = false;
                
                // Set camera target for better viewing
                if (controls && currentSplat) {
                    const bounds = currentSplat.bounds;
                    const center = bounds.center();
                    const distance = bounds.size().length() * 2;
                    
                    camera.position.set(center.x, center.y + distance * 0.5, center.z + distance);
                    controls.setCameraTarget(center);
                    debugLog('Camera positioned for optimal viewing');
                }
                
            } catch (error) {
                updateStatus(`‚ùå Failed to load first frame: ${error.message}`, 'error');
                debugLog(`Load failed: ${error.message}`);
                
                loadFirstBtn.textContent = '‚ùå Failed';
                setTimeout(() => {
                    loadFirstBtn.textContent = 'üé¨ Load Frame 1';
                    loadFirstBtn.disabled = false;
                }, 2000);
            }
        }

        function toggleSequence() {
            if (!sequencePlayer) {
                updateStatus('‚ùå Load first frame first!', 'error');
                return;
            }
            
            if (sequencePlayer.isPlaying) {
                sequencePlayer.stop();
                playBtn.textContent = '‚ñ∂Ô∏è Play Sequence';
            } else {
                sequencePlayer.playSequence();
                playBtn.textContent = '‚è∏Ô∏è Stop';
            }
        }

        function startAR() {
            if (!currentSplat) {
                updateStatus('‚ùå Load a frame first!', 'error');
                return;
            }
            
            updateStatus('üöÄ AR mode - Click anywhere to place splat', 'info');
            
            // Simple click-to-place AR simulation
            const arPlacement = (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // Move current splat to clicked position
                if (currentSplat) {
                    currentSplat.position.set(x * 5, 0, y * 5);
                    updateStatus('‚úÖ Splat placed! Sequence will play at new location', 'success');
                }
                
                canvas.removeEventListener('click', arPlacement);
            };
            
            canvas.addEventListener('click', arPlacement);
        }

        // Window resize handler
        function handleResize() {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            if (camera && renderer) {
                camera.data.setSize(width, height);
                renderer.setSize(width, height);
            }
        }

        // Main application entry point
        async function main() {
            try {
                updateLoadingText('Loading gsplat.js library...');
                const gSplatLoaded = await loadGsplat();
                
                if (!gSplatLoaded) {
                    throw new Error('Failed to load gsplat.js library');
                }
                
                updateLoadingText('Initializing gsplat.js...');
                const gSplatReady = await initializeGSplat();
                
                if (!gSplatReady) {
                    throw new Error('Failed to initialize gsplat.js');
                }
                
                updateLoadingText('Starting render loop...');
                startRenderLoop();
                
                // Hide loading screen
                loading.classList.add('hidden');
                updateStatus('‚úÖ Ready! Click "Load Frame 1" to test .splat loading', 'success');
                debugLog('üéØ Application initialized successfully');
                
            } catch (error) {
                updateStatus(`‚ùå Application failed to start: ${error.message}`, 'error');
                debugLog(`Main error: ${error.message}`);
                loading.classList.add('hidden');
            }
        }

        // Event listeners
        window.addEventListener('resize', handleResize);

        // Global functions for buttons
        window.loadFirstFrame = loadFirstFrame;
        window.toggleSequence = toggleSequence;
        window.startAR = startAR;

        // Start the application
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', main);
        } else {
            main();
        }

        console.log('üé≠ AR Splat Demo - Proper .splat Loading');
        console.log('üéØ Using gsplat.js Loader.LoadAsync() for individual .splat files');
        console.log('üìä SplatData.RowLength = 32 bytes per gaussian');

    </script>
</body>
</html>