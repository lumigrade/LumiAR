<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé≠ AR Splat 400-Frame Sequence Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            overflow-x: hidden;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            backdrop-filter: blur(10px);
        }

        .status {
            position: fixed;
            top: 70px;
            left: 20px;
            right: 20px;
            z-index: 150;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .status.success { background: rgba(46, 204, 113, 0.8); }
        .status.error { background: rgba(231, 76, 60, 0.8); }
        .status.info { background: rgba(52, 152, 219, 0.8); }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #3498db;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            touch-action: none;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-btn {
            padding: 12px 20px;
            background: rgba(52, 152, 219, 0.9);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .control-btn:hover {
            background: rgba(52, 152, 219, 1);
            transform: scale(1.05);
        }

        .control-btn:disabled {
            background: rgba(127, 140, 141, 0.5);
            cursor: not-allowed;
            transform: none;
        }

        .ar-button {
            background: rgba(46, 204, 113, 0.9);
        }

        .ar-button:hover {
            background: rgba(46, 204, 113, 1);
        }

        .playback-info {
            position: fixed;
            top: 120px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
            display: none;
        }

        .playback-info.visible {
            display: block;
        }

        .debug {
            position: fixed;
            top: 120px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 10px;
            font-family: monospace;
            z-index: 100;
            max-height: 300px;
            max-width: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé≠ AR Splat 400-Frame Sequence Player</h1>
        <p>Gaussian Splat sequence animation with AR placement</p>
    </div>

    <div class="status" id="status">Initializing...</div>

    <div class="playback-info" id="playbackInfo">
        <div>Frame: <span id="currentFrame">0</span>/<span id="totalFrames">400</span></div>
        <div>FPS: <span id="currentFPS">0</span></div>
        <div>Gaussians: <span id="gaussianCount">0</span></div>
        <div>Status: <span id="playStatus">Stopped</span></div>
    </div>

    <div class="debug" id="debug">
        Debug log:<br>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div id="loadingText">Initializing gsplat.js...</div>
    </div>

    <canvas id="canvas3d"></canvas>

    <div class="controls">
        <button class="control-btn" id="loadBtn" onclick="loadAllFrames()">üé¨ Load All 400 Frames</button>
        <button class="control-btn" id="playBtn" onclick="togglePlayback()" disabled>‚ñ∂Ô∏è Play Sequence</button>
        <button class="ar-button control-btn" id="arBtn" onclick="startAR()" disabled>üöÄ AR Mode</button>
    </div>

    <script type="module">
        // Global variables - keeping it simple like the working test
        let SPLAT = null;
        let scene, camera, renderer, controls;
        let sequencePlayer = null;

        // DOM elements
        const canvas = document.getElementById('canvas3d');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const debug = document.getElementById('debug');
        const playbackInfo = document.getElementById('playbackInfo');
        const loadBtn = document.getElementById('loadBtn');
        const playBtn = document.getElementById('playBtn');
        const arBtn = document.getElementById('arBtn');

        // Debug logging - exactly like the working test
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] ${message}`);
            debug.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            debug.scrollTop = debug.scrollHeight;
        }

        // Status updates
        function updateStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            log(`STATUS [${type}]: ${message}`);
        }

        function updateLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
            log(`LOADING: ${text}`);
        }

        // Professional Sequence Player with full preload and frame blending
        class ProfessionalSequencePlayer {
            constructor() {
                this.folderPath = './data/splat';
                this.maxFrames = 400;
                this.currentFrame = 1;
                this.isPlaying = false;
                this.currentSplat = null;
                this.targetFPS = 25;
                this.frameInterval = 1000 / this.targetFPS;
                this.lastFrameTime = 0;
                this.actualFPS = 0;
                this.fpsCounter = 0;
                this.fpsStartTime = Date.now();
                this.isLoaded = false;
                
                // Full frame storage - load ALL frames
                this.allFrames = new Map();
                this.loadingProgress = 0;
                this.totalFramesToLoad = this.maxFrames;
                
                // Frame blending for smooth transitions
                this.enableBlending = true;
                this.blendDuration = 50; // ms for blend transition
                this.currentBlendTime = 0;
                this.isBlending = false;
                this.previousSplat = null;
                
                log('üé¨ Professional sequence player created - will load all 400 frames');
            }

            async loadAllFrames() {
                try {
                    updateStatus('Loading all 400 frames... 0%', 'info');
                    log('üì• Starting to load all 400 frames...');
                    
                    // Clear everything first
                    scene.reset();
                    this.allFrames.clear();
                    this.currentSplat = null;
                    this.loadingProgress = 0;
                    
                    const startTime = Date.now();
                    let loadedCount = 0;
                    
                    // Load frames in batches for better progress feedback
                    const batchSize = 10; // Load 10 frames at a time
                    
                    for (let batchStart = 1; batchStart <= this.maxFrames; batchStart += batchSize) {
                        const batchEnd = Math.min(batchStart + batchSize - 1, this.maxFrames);
                        const batchFrames = [];
                        
                        // Create batch of frame numbers
                        for (let frameNum = batchStart; frameNum <= batchEnd; frameNum++) {
                            batchFrames.push(frameNum);
                        }
                        
                        log(`üì¶ Loading batch: frames ${batchStart} to ${batchEnd}`);
                        
                        // Load batch in parallel
                        const batchPromises = batchFrames.map(async (frameNum) => {
                            try {
                                const frameNumStr = frameNum.toString().padStart(6, '0');
                                const url = `${this.folderPath}/frame_${frameNumStr}.splat`;
                                
                                const response = await fetch(url);
                                if (!response.ok) {
                                    throw new Error(`Frame ${frameNum} not found: ${response.status}`);
                                }
                                
                                const arrayBuffer = await response.arrayBuffer();
                                const buffer = new Uint8Array(arrayBuffer);
                                const data = SPLAT.SplatData.Deserialize(buffer);
                                const splat = new SPLAT.Splat(data);
                                
                                this.allFrames.set(frameNum, splat);
                                loadedCount++;
                                
                                // Update progress
                                this.loadingProgress = Math.round((loadedCount / this.totalFramesToLoad) * 100);
                                updateStatus(`Loading all frames... ${this.loadingProgress}%`, 'info');
                                
                                return { frameNum, splat, gaussians: data.vertexCount };
                                
                            } catch (error) {
                                log(`‚ùå Failed to load frame ${frameNum}: ${error.message}`);
                                throw error;
                            }
                        });
                        
                        // Wait for batch to complete
                        const batchResults = await Promise.allSettled(batchPromises);
                        
                        // Check for failures
                        const failures = batchResults.filter(result => result.status === 'rejected');
                        if (failures.length > 0) {
                            log(`‚ö†Ô∏è ${failures.length} frames failed in batch ${batchStart}-${batchEnd}`);
                        }
                        
                        // Small delay between batches to keep UI responsive
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    
                    const loadTime = (Date.now() - startTime) / 1000;
                    
                    if (this.allFrames.size === this.maxFrames) {
                        // All frames loaded successfully
                        this.isLoaded = true;
                        
                        // Set up first frame
                        const firstFrame = this.allFrames.get(1);
                        if (firstFrame) {
                            scene.addObject(firstFrame);
                            this.currentSplat = firstFrame;
                            this.currentFrame = 1;
                            this.positionCamera(firstFrame);
                        }
                        
                        updateStatus(`‚úÖ All 400 frames loaded in ${loadTime.toFixed(1)}s! Ready for smooth playback`, 'success');
                        log(`‚úÖ Successfully loaded all ${this.allFrames.size} frames in ${loadTime.toFixed(1)}s`);
                        log(`üìä First frame: ${firstFrame.data.vertexCount} gaussians`);
                        
                        return true;
                    } else {
                        throw new Error(`Only loaded ${this.allFrames.size}/${this.maxFrames} frames`);
                    }
                    
                } catch (error) {
                    updateStatus(`‚ùå Failed to load all frames: ${error.message}`, 'error');
                    log(`‚ùå Load all frames failed: ${error.message}`);
                    return false;
                }
            }

            positionCamera(splat) {
                if (!controls) return;
                
                try {
                    const bounds = splat.bounds;
                    const center = bounds.center();
                    const size = bounds.size();
                    const distance = Math.sqrt(size.x * size.x + size.y * size.y + size.z * size.z) * 2;
                    
                    camera.position = new SPLAT.Vector3(
                        center.x + distance * 0.7,
                        center.y + distance * 0.5,
                        center.z + distance * 0.7
                    );
                    controls.setCameraTarget(center);
                    
                    log(`üìπ Camera positioned at distance ${distance.toFixed(2)}`);
                } catch (error) {
                    log(`‚ö†Ô∏è Camera positioning failed: ${error.message}`);
                }
            }

            smoothSplatTransition(newSplat) {
                if (!this.enableBlending || !this.currentSplat) {
                    // No blending, direct replacement
                    if (this.currentSplat) {
                        scene.removeObject(this.currentSplat);
                    }
                    scene.addObject(newSplat);
                    this.currentSplat = newSplat;
                    return;
                }
                
                // Start blend transition
                this.previousSplat = this.currentSplat;
                this.currentSplat = newSplat;
                this.isBlending = true;
                this.currentBlendTime = 0;
                
                // Add new splat to scene (will blend in)
                scene.addObject(newSplat);
                
                // Start blend animation
                this.performBlendTransition();
            }

            performBlendTransition() {
                if (!this.isBlending) return;
                
                const blendProgress = Math.min(this.currentBlendTime / this.blendDuration, 1.0);
                
                try {
                    // Fade out previous splat
                    if (this.previousSplat && this.previousSplat.material) {
                        this.previousSplat.material.opacity = 1.0 - blendProgress;
                        this.previousSplat.material.transparent = true;
                    }
                    
                    // Fade in current splat
                    if (this.currentSplat && this.currentSplat.material) {
                        this.currentSplat.material.opacity = blendProgress;
                        this.currentSplat.material.transparent = blendProgress < 1.0;
                    }
                } catch (error) {
                    // If material blending fails, fall back to direct replacement
                    log(`‚ö†Ô∏è Blend transition failed, using direct replacement: ${error.message}`);
                    this.enableBlending = false;
                    
                    if (this.previousSplat) {
                        scene.removeObject(this.previousSplat);
                    }
                    this.isBlending = false;
                    return;
                }
                
                this.currentBlendTime += 16; // Assuming ~60fps for smooth blending
                
                if (blendProgress >= 1.0) {
                    // Blend complete
                    if (this.previousSplat) {
                        scene.removeObject(this.previousSplat);
                    }
                    
                    // Ensure current splat is fully opaque
                    if (this.currentSplat && this.currentSplat.material) {
                        this.currentSplat.material.opacity = 1.0;
                        this.currentSplat.material.transparent = false;
                    }
                    
                    this.isBlending = false;
                    this.previousSplat = null;
                } else {
                    // Continue blending
                    requestAnimationFrame(() => this.performBlendTransition());
                }
            }

            async startSequence() {
                if (!this.isLoaded) {
                    updateStatus('‚ùå Load all frames first!', 'error');
                    return;
                }

                if (this.isPlaying) return;
                
                this.isPlaying = true;
                this.lastFrameTime = performance.now();
                this.fpsStartTime = performance.now();
                this.fpsCounter = 0;
                
                updateStatus('‚ñ∂Ô∏è Playing smooth 400-frame sequence with frame blending', 'success');
                log(`‚ñ∂Ô∏è Starting professional sequence playback from frame ${this.currentFrame}`);
                playbackInfo.classList.add('visible');
                
                this.animationLoop();
            }

            async animationLoop() {
                if (!this.isPlaying) return;
                
                const now = performance.now();
                const deltaTime = now - this.lastFrameTime;
                
                if (deltaTime >= this.frameInterval) {
                    this.nextFrame();
                    this.lastFrameTime = now;
                    
                    // Calculate FPS
                    this.fpsCounter++;
                    if (this.fpsCounter % 5 === 0) {
                        const elapsed = (now - this.fpsStartTime) / 1000;
                        this.actualFPS = Math.round(this.fpsCounter / elapsed);
                    }
                }
                
                if (this.isPlaying) {
                    requestAnimationFrame(() => this.animationLoop());
                }
            }

            nextFrame() {
                this.currentFrame++;
                if (this.currentFrame > this.maxFrames) {
                    this.currentFrame = 1; // Loop back
                    log('üîÑ Sequence looped back to frame 1');
                }
                
                // Get frame instantly from memory (no loading!)
                const frame = this.allFrames.get(this.currentFrame);
                if (frame) {
                    // Smooth transition with blending
                    this.smoothSplatTransition(frame);
                    
                    this.updatePlaybackInfo();
                    
                    if (this.currentFrame % 25 === 0) {
                        log(`üìä Professional playback: frame ${this.currentFrame}/${this.maxFrames}, FPS: ${this.actualFPS}`);
                    }
                } else {
                    log(`‚ùå Frame ${this.currentFrame} not found in memory!`);
                }
            }

            stop() {
                this.isPlaying = false;
                this.isBlending = false;
                playbackInfo.classList.remove('visible');
                updateStatus('‚èπÔ∏è Professional sequence stopped', 'info');
                log(`‚èπÔ∏è Stopped at frame ${this.currentFrame}`);
            }

            updatePlaybackInfo() {
                if (!this.currentSplat) return;
                
                document.getElementById('currentFrame').textContent = this.currentFrame;
                document.getElementById('currentFPS').textContent = this.actualFPS;
                document.getElementById('gaussianCount').textContent = this.currentSplat.data.vertexCount.toLocaleString();
                document.getElementById('playStatus').textContent = this.isPlaying ? `Playing (${this.allFrames.size} loaded)` : 'Ready';
            }

            placeInAR(position) {
                if (this.currentSplat) {
                    this.currentSplat.position = new SPLAT.Vector3(position.x, position.y, position.z);
                    
                    // Apply same position to all frames for consistent AR placement
                    this.allFrames.forEach(splat => {
                        splat.position = new SPLAT.Vector3(position.x, position.y, position.z);
                    });
                    
                    updateStatus('üöÄ AR Mode: Professional sequence placed with blending!', 'success');
                    log(`üöÄ AR placement applied to all ${this.allFrames.size} frames: [${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}]`);
                }
            }

            dispose() {
                this.stop();
                
                // Clean up all frames
                this.allFrames.forEach(splat => {
                    if (scene.objects.includes(splat)) {
                        scene.removeObject(splat);
                    }
                });
                this.allFrames.clear();
                
                log('üóëÔ∏è Professional sequence player disposed - all frames cleaned');
            }
        }

        // Import gsplat.js - using the exact working method
        async function loadGsplat() {
            try {
                // Add console.assert polyfill (gsplat.js needs this)
                if (!console.assert) {
                    console.assert = function(condition, message) {
                        if (!condition) {
                            console.error('Assertion failed:', message || 'Assertion failed');
                            throw new Error(message || 'Assertion failed');
                        }
                    };
                    log('‚úÖ console.assert polyfill added');
                }

                updateLoadingText('Loading gsplat.js library...');
                log('üì¶ Importing gsplat.js from CDN...');
                
                SPLAT = await import('https://cdn.jsdelivr.net/npm/gsplat@latest/dist/index.js');
                
                log(`‚úÖ gsplat.js imported successfully`);
                log(`üìã Available classes: ${Object.keys(SPLAT).join(', ')}`);
                
                return true;
            } catch (error) {
                log(`‚ùå Failed to import gsplat.js: ${error.message}`);
                log(`üìã Error stack: ${error.stack}`);
                return false;
            }
        }

        // Initialize gsplat.js - using the exact working method
        async function initializeGSplat() {
            try {
                updateLoadingText('Creating scene...');
                log('üèóÔ∏è Creating SPLAT.Scene()...');
                scene = new SPLAT.Scene();
                log('‚úÖ Scene created');
                
                updateLoadingText('Creating camera...');
                log('üìπ Creating SPLAT.Camera()...');
                camera = new SPLAT.Camera();
                camera.position = new SPLAT.Vector3(0, 1.6, 3);
                log('‚úÖ Camera created and positioned');
                
                updateLoadingText('Creating renderer...');
                log('üñºÔ∏è Creating SPLAT.WebGLRenderer()...');
                renderer = new SPLAT.WebGLRenderer(canvas);
                log('‚úÖ Renderer created');
                
                updateLoadingText('Setting up controls...');
                log('üéÆ Creating SPLAT.OrbitControls()...');
                controls = new SPLAT.OrbitControls(camera, canvas);
                log('‚úÖ Controls created');
                
                updateLoadingText('Configuring viewport...');
                log('üìê Configuring camera and renderer sizes...');
                camera.data.setSize(window.innerWidth, window.innerHeight);
                renderer.setSize(window.innerWidth, window.innerHeight);
                log('‚úÖ Viewport configured');
                
                return true;
                
            } catch (error) {
                log(`‚ùå Initialization failed: ${error.message}`);
                log(`üìã Error stack: ${error.stack}`);
                return false;
            }
        }

        // Start render loop - using the exact working method
        function startRenderLoop() {
            log('üîÑ Starting render loop...');
            
            function render() {
                try {
                    if (controls) {
                        controls.update();
                    }
                    
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                } catch (error) {
                    if (!render.errorLogged) {
                        log(`‚ùå Render error: ${error.message}`);
                        render.errorLogged = true;
                    }
                }
                requestAnimationFrame(render);
            }
            
            render();
            log('‚úÖ Render loop started');
        }

        // Button functions
        async function loadAllFrames() {
            if (!SPLAT) {
                updateStatus('‚ùå gsplat.js not loaded!', 'error');
                return;
            }

            loadBtn.disabled = true;
            loadBtn.textContent = 'üîÑ Loading 0%...';
            
            try {
                // Create professional sequence player
                sequencePlayer = new ProfessionalSequencePlayer();
                
                // Load all 400 frames with progress
                const success = await sequencePlayer.loadAllFrames();
                
                if (success) {
                    loadBtn.textContent = '‚úÖ All 400 Loaded';
                    playBtn.disabled = false;
                    arBtn.disabled = false;
                } else {
                    loadBtn.textContent = '‚ùå Failed';
                    setTimeout(() => {
                        loadBtn.textContent = 'üé¨ Load All 400 Frames';
                        loadBtn.disabled = false;
                    }, 3000);
                }
                
            } catch (error) {
                log(`‚ùå Load all frames error: ${error.message}`);
                loadBtn.textContent = '‚ùå Failed';
                setTimeout(() => {
                    loadBtn.textContent = 'üé¨ Load All 400 Frames';
                    loadBtn.disabled = false;
                }, 3000);
            }
        };
        function togglePlayback() {
            if (!sequencePlayer || !sequencePlayer.isLoaded) {
                updateStatus('‚ùå Load all frames first!', 'error');
                return;
            }
            
            if (sequencePlayer.isPlaying) {
                sequencePlayer.stop();
                playBtn.textContent = '‚ñ∂Ô∏è Play Sequence';
            } else {
                sequencePlayer.startSequence();
                playBtn.textContent = '‚è∏Ô∏è Stop';
            }
        }

        function startAR() {
            if (!sequencePlayer || !sequencePlayer.isLoaded) {
                updateStatus('‚ùå Load all frames first!', 'error');
                return;
            }
            
            updateStatus('üéØ AR Mode - Tap anywhere to place sequence', 'info');
            
            // Simple click-to-place AR
            const arPlacement = (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                const position = {
                    x: x * 5,
                    y: 0,
                    z: y * 5
                };
                
                sequencePlayer.placeInAR(position);
                canvas.removeEventListener('click', arPlacement);
            };
            
            canvas.addEventListener('click', arPlacement);
        }

        // Window resize handler
        function handleResize() {
            if (camera && renderer) {
                camera.data.setSize(window.innerWidth, window.innerHeight);
                renderer.setSize(window.innerWidth, window.innerHeight);
                log('üìê Window resized, viewport updated');
            }
        }

        // Main initialization - using the exact working method
        async function main() {
            try {
                log('üöÄ Starting application...');
                
                const gSplatLoaded = await loadGsplat();
                if (!gSplatLoaded) {
                    throw new Error('Failed to load gsplat.js');
                }
                
                const gSplatReady = await initializeGSplat();
                if (!gSplatReady) {
                    throw new Error('Failed to initialize gsplat.js');
                }
                
                startRenderLoop();
                
                // Hide loading, enable test button
                loading.classList.add('hidden');
                updateStatus('‚úÖ Ready! Click "Load All 400 Frames" for professional playback', 'success');
                log('üéØ Application ready - professional sequence player initialized');
                
            } catch (error) {
                log(`‚ùå Application startup failed: ${error.message}`);
                updateStatus(`‚ùå Startup failed: ${error.message}`, 'error');
                loading.classList.add('hidden');
            }
        }

        // Event listeners
        window.addEventListener('resize', handleResize);
        
        // Global functions for buttons
        window.loadAllFrames = loadAllFrames;
        window.togglePlayback = togglePlayback;
        window.startAR = startAR;

        // Start the application - same as working test
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', main);
        } else {
            main();
        }

        console.log('üé≠ Professional AR Splat Sequence Player');
        console.log('üéØ Features: Full 400-frame preload, frame blending, smooth 25fps');
        console.log('üìä Memory: ~220MB for all frames, zero loading during playback');

    </script>
</body>
</html>